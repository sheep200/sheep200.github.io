<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome gods!</title>
    <url>/2021/08/03/hello-world/</url>
    <content><![CDATA[<h2 id="Welcome-gods"><a href="#Welcome-gods" class="headerlink" title="Welcome gods!"></a>Welcome gods!</h2><h3 id="LF-mac"><a href="#LF-mac" class="headerlink" title="LF.mac"></a>LF.mac</h3><h3 id="luv-letters"><a href="#luv-letters" class="headerlink" title="luv_letters"></a><a href="https://dancekey.github.io/">luv_letters</a></h3><h3 id="Vanassian"><a href="#Vanassian" class="headerlink" title="Vanassian"></a><a href="https://vanassian.github.io/">Vanassian</a></h3><p>芜湖！</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>gods!</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾电源板 &amp; 延期电赛 Best match!</title>
    <url>/2021/08/07/powerPCB/</url>
    <content><![CDATA[<h1 id="Non-existing-electronic-design-competition"><a href="#Non-existing-electronic-design-competition" class="headerlink" title="Non-existing electronic design competition"></a>Non-existing electronic design competition</h1><p>不存在的电赛</p>
<hr>
<blockquote>
<p>引子<br>由于这个新的病毒所带来的疫情，智能车竞赛以一种既坎坷又顺利的方式度过了。<br><del>甚至有一个单车组不用参加国赛就可以拿国二，大酸</del><br>最玄幻的展开真就被我们这一届赶上了</p>
</blockquote>
<hr>
<h2 id="说说电赛"><a href="#说说电赛" class="headerlink" title="说说电赛~"></a>说说电赛~</h2><p>先是延期一周，然后就变成了<strong>无限制延期</strong>，官方发布的通知就变成了等到疫情好转再<em>择机举行</em>。<br>反正是近期无望了，疫情也是没有办法的事。<br>我就没什么脾气，本来没有什么准备时间的一场没有把握的比赛，突然有了相当长的准备时间，反而很不适应。<br>不知道从何做起的话，就画画<strong>电源板</strong>吧！<br><del>总算回到正题</del></p>
<h2 id="电源板传"><a href="#电源板传" class="headerlink" title="电源板传"></a>电源板传</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://z3.ax1x.com/2021/08/22/fzXfp9.png" width="40%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">看“板”娘——雷蛇小姐</div>
</center>

<p>电源板又称供电板，功能很容易理解，就是插上去一块电赛标准的<em>12V电池</em>，能给我输出很多种不同的电压的板子。用来给各种外设供电的。<br>基本上回到家才开始设计的。<br>第一天完成元器件的选型和原理图的绘制。<br>第二天完成封装的导出绘制和添加，以及元器件的布局。<br>第三天上午完成了布线和检查，中午就交付打板了。<br>基本上是边摸鱼边干活，在家效率还是比较低。而且确实有很久都没有从头设计板子了，自从上个寒假设计完了一套主板电驱运放的方案，期间也就做了一版新运放，基本操作也就是对原方案缝缝补补以及修板子，至于交互板就更没有技术含量了，做PCB有些生疏了。<br>而且全程我查到的资料比较少，主要是参考了之前打电赛的某些队伍的技术报告，我看到的报告对电源板的设计并不是很详细。我的这块板基本上是融合一些技术报告的内容再加上我自己的想象设计出来的。那些技术报告参差不齐的，到时候能不能满足要求都难说_(:з」∠)_<br><strong>因为我根本就不知道要用哪些外设啊喂！</strong></p>
<h2 id="电源板参数"><a href="#电源板参数" class="headerlink" title="电源板参数"></a>电源板参数</h2><p>目前还不知道能不能用，就放一张原理图凑合一下罢<br><a href="https://www.hualigs.cn/image/610eb522a8264.jpg">电源板原理图</a><br>这里面最让我心虚的一点就是正负12V没有稳压，等于说正负电源就只有电源正负电压和5V正负电压，如果用到12V双电源很大概率要翻车。</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python图像边缘检测</title>
    <url>/2021/08/08/imageEdge/</url>
    <content><![CDATA[<h1 id="图像边缘检测（多图警告）"><a href="#图像边缘检测（多图警告）" class="headerlink" title="图像边缘检测（多图警告）"></a>图像边缘检测（多图警告）</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>画完了电源板厂家还没做好，这几天是闲的。本来画板子的时候因为各种事情心烦意乱的非常烦躁，现在又感觉非常空虚····<br>突然想起来画板的时候遇到的一个问题，就是那个看板娘丝印的处理。AD在导入图像的时候只能导入二值图，而原本一个丰富多彩的图像转化成灰度图，再转化成二值图的最终效果实在是太差了，只剩下色块，根本认不出来，后来是还是我自己用数位板描出来了五官，添加了亮部和暗部的一点细节，最终的看板娘二值图才勉强能看。用PS直接处理弄弄图标什么的还凑合，弄一个稍微复杂的图像就根本不行（可能是我PS技术太烂了罢）。<br>此时我就想起来之前见同学用Python做了个图像边缘识别，觉得把边缘识别得到的图像与PS直接做出来的图像结合一下，前者负责勾勒物体轮廓，后者负责填充明暗，效果应该会好上不少。于是今天就来复现一下同学的图像处理~<br>废话少说！</p>
</blockquote>
<h2 id="前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。"><a href="#前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。" class="headerlink" title="前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。"></a>前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。</h2><p>以一张 <strong>红泳装皮肤同人图</strong> 为例，这是原图：</p>
<center>
<img src="https://www.hualigs.cn/image/610faeea0295d.jpg" width="40%" alt=""/>
</center>

<h3 id="如果用PS像上面描述的那样处理的话，效果是这样的"><a href="#如果用PS像上面描述的那样处理的话，效果是这样的" class="headerlink" title="如果用PS像上面描述的那样处理的话，效果是这样的~"></a>如果用PS像上面描述的那样处理的话，效果是这样的~</h3><h4 id="先PS调成灰度图："><a href="#先PS调成灰度图：" class="headerlink" title="先PS调成灰度图："></a>先PS调成灰度图：</h4><center>
<img src="https://www.hualigs.cn/image/610fa7069b643.jpg" width="40%" alt=""/>
</center>

<h4 id="再PS色彩分离，将色阶将至2（黑和白）"><a href="#再PS色彩分离，将色阶将至2（黑和白）" class="headerlink" title="再PS色彩分离，将色阶将至2（黑和白）"></a>再PS色彩分离，将色阶将至2（黑和白）</h4><center>
<img src="https://z3.ax1x.com/2021/08/22/hSSCKs.jpg" width="40%" alt=""/>
</center>
<center style='color:gray;'> 好像也挺帅？ </center>

<p>这张还可以看出五官，但是相信我，很多图像是不行的，而且大量的亮部和暗部的轮廓都会消失。<br>下面就来尝试用Python处理一下这张图片吧~</p>
<h1 id="基础的Python图像边缘识别"><a href="#基础的Python图像边缘识别" class="headerlink" title="基础的Python图像边缘识别"></a>基础的Python图像边缘识别</h1><p>这里用的图像处理的库是OpenCv的。</p>
<h2 id="1-库的安装"><a href="#1-库的安装" class="headerlink" title="1.库的安装"></a>1.库的安装</h2><center style='color:gray;'> 安装库是第一步，也是最后一步，什么叫面向CSDN编程啊（战术后仰</center>


<p>电脑上需要有Python，我用的是Python3.6.4<br>首先要安装numpy，命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>
<p>安装完之后再安装cv:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install opencv_python</span><br></pre></td></tr></table></figure>
<p>这样库就安好了</p>
<blockquote>
<p>因为我不是在新电脑上学的啊，原来可能就有一些库，要完成接下来的操作可能还会缺一个库，就是matplot。这个库是Python画图用的，并不是必须的。不过建议自己搜索安装一个。</p>
</blockquote>
<h2 id="2-库引入"><a href="#2-库引入" class="headerlink" title="2.库引入"></a>2.库引入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>没什么好说的</p>
<h2 id="3-图像读取"><a href="#3-图像读取" class="headerlink" title="3.图像读取"></a>3.图像读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">original_img = cv2.imread(<span class="string">&quot;D:/red.jpg&quot;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这个cv2.imread函数除了可以指定图片的地址，还可以指定读取的通道数。像这里用的是 0 ，这样其实读出来的图像就已经是灰度图了。<br>把后面的“，0”去掉，图像才会是原图。</p>
<h2 id="4-canny边缘检测"><a href="#4-canny边缘检测" class="headerlink" title="4.canny边缘检测"></a>4.canny边缘检测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img1 = cv2.GaussianBlur(original_img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">canny = cv2.Canny(img1, <span class="number">50</span>, <span class="number">150</span>)</span><br></pre></td></tr></table></figure>
<p>canny函数只能处理灰度图，前面已经完成了彩图到灰度图的转化。<br>用高斯平滑处理原图像降噪。<br>再用canny指定最大和最小阈值，提取边缘。</p>
<blockquote>
<p>OpenCV-Python中Canny函数的原型为：<br>edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]])<br>必要参数：<br>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图；<br>第二个参数是阈值1；<br>第三个参数是阈值2。<br>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候用较小的第一个阈值用于将这些间断的边缘连接起来。<br>原文链接：<a href="https://blog.csdn.net/sunny2038/article/details/9202641">https://blog.csdn.net/sunny2038/article/details/9202641</a></p>
</blockquote>
<h2 id="5-色彩反向"><a href="#5-色彩反向" class="headerlink" title="5.色彩反向"></a>5.色彩反向</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height,width = canny.shape</span><br><span class="line">cannyturn = np.zeros((height,width,<span class="number">1</span>),np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        cannyturn[i,j] = <span class="number">255</span> - canny[i,j]</span><br></pre></td></tr></table></figure>
<p>这一步只是为了用黑色显示轮廓，白色当背景而已。canny默认的是黑色背景，白色轮廓。<br>方法非常无脑，生成另外一个相同大小的图像，然后将原图像的每一个像素点颜色数值反过来，赋给新图像。就完事了。<br>这一步可以省去，只不过是用AD脚本转化的时候方便一点而已。</p>
<h2 id="6-画图显示"><a href="#6-画图显示" class="headerlink" title="6.画图显示"></a>6.画图显示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(original_img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),plt.imshow(canny,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Canny&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这一步是为了将图像显示一下，简单对比一下效果。</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 3px 6px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/610fb91c5a155.jpg" width="80%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">这一步运行弹出的窗口</div>
</center>
同样可以省去的

<h2 id="7-图像保存"><a href="#7-图像保存" class="headerlink" title="7.图像保存"></a>7.图像保存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;black2.jpg&#x27;</span>,cannyturn)</span><br></pre></td></tr></table></figure>
<p>默认保存在Python程序所在的文件夹<br>最终效果：</p>
<center>
<img src="https://www.hualigs.cn/image/610fa704c408f.jpg" width="40%" alt=""/>
</center>
<center style='color:gray;'> 建议点开看 </center>
如果觉得边缘还是不明显的话，可以降低canny函数的阈值。
而且上面所述的方法忽略了一步，就是彩图向灰度图的转化。实际上RGB彩图向灰度图的转化有很多种方法，这里是在采集图像的时候就直接按照灰度通道采集。如果在这里做些手脚的话，效果也许会更好。这会意味着更大的调整空间 ~~以及更多参数要调~~

<p>不过就观感来看，这个轮廓图相较于单纯的二值图过分单薄了些。后续我会考虑如何用Python将两者结合起来，兼顾轮廓与明暗色块。这样放在电路板上当看“板”娘才有范儿~</p>
<hr>
<center style='color:green;'> 更新分割线 2021/8/8（没错还是今天） </center>

<blockquote>
<h2 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h2><p>受到那个粗暴的反向方法的启发，我弄了一个二值图与轮廓图的融合方法。最终成品效果应该是比单独的两张图都好上一些的。反正出来之后，效果就是预想的效果，心中有一丝没有遇上惊喜的失落。</p>
</blockquote>
<h1 id="二值图与轮廓图的融合"><a href="#二值图与轮廓图的融合" class="headerlink" title="二值图与轮廓图的融合"></a>二值图与轮廓图的融合</h1><h2 id="1-二值图的获取"><a href="#1-二值图的获取" class="headerlink" title="1.二值图的获取"></a>1.二值图的获取</h2><p>之前用PS获得过二值图，Python中还需要完成一步灰度图向二值图的转化。<br>自创的转化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二值图生成</span></span><br><span class="line">height2,width2 = img1.shape</span><br><span class="line">bmp = np.zeros((height2,width2,<span class="number">1</span>),np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height2):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width2):</span><br><span class="line">        <span class="keyword">if</span> img1[i,j] &gt;= <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">255</span></span><br><span class="line">        <span class="keyword">elif</span> img1[i,j] &lt; <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>效果和用PS做出来的效果几乎一样~</p>
<center>
<img src="https://www.hualigs.cn/image/6110042694ef1.jpg" width="40%" alt=""/>
</center>

<h2 id="2-二值图与轮廓图的融合"><a href="#2-二值图与轮廓图的融合" class="headerlink" title="2.二值图与轮廓图的融合"></a>2.二值图与轮廓图的融合</h2><p>主要思路就是用轮廓的信息对二值图进行描绘<br>将二值图中白的地方刮黑，黑的地方刮白，以此呈现出被二值掉的轮廓。<br>上代码~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#融合--融合在bmp上</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height2):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width2):</span><br><span class="line">        <span class="keyword">if</span> canny[i,j] &gt; <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">255</span> - bmp[i,j]</span><br></pre></td></tr></table></figure>
<p>直接看最终效果~</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/611005f32a317.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">二值图能做到这样，已经是极限了罢（悲 </div>
</center>

<p>怎么说呢，这张图远看跟二值图没区别，近看才会有明显的效果。跟原来两张图一比较还是会好上一些。<br>有新的参数可以调了！<br>二值化的阈值。这个参数控制图片亮部和暗部的范围，对于整体观感是肯定有影响的。<br>能想到的改进方向还有轮廓的粗细，二值化算法等等，以后再说吧。</p>
<hr>
<center style='color:green;'> 更新分割线2021/8/9 </center>

<h1 id="动态调参"><a href="#动态调参" class="headerlink" title="动态调参"></a>动态调参</h1><blockquote>
<h2 id="引子-2"><a href="#引子-2" class="headerlink" title="引子"></a>引子</h2><p>既然之前提到了参数，对于效果不好的图像，最基础的操作当然是关掉页面，回到VScode中修改参数再运行一次。虽然这对于Python程序而言比较简单，毕竟是解释性的语言，对于动态调参的需求没有嵌入式那么高，我还是弄了一个动态调参的东西。实不实用不重要，重要是帅啊。</p>
</blockquote>
<p>在说动态调参之前，还有一个小玩意儿分享一下~</p>
<h2 id="0-图层蒙板"><a href="#0-图层蒙板" class="headerlink" title="0.图层蒙板"></a>0.图层蒙板</h2><p>既然是做图像处理，图层是一个很重要的概念。虽然Python并不能对一个图像保存多个图层进行处理（Adobe还是永远的神），但是可以在两张图片之间使用蒙板，这已经很有图层的味了。</p>
<blockquote>
<p>转念一想，图像既然是按照像素储存在二维数组里的，如果换成三维数组，那岂不是可以有很多层的图片？退一步讲，其实只要定义很多张相同大小的图片，人为的给他们排上顺序，其实就已经是图层了。格局小了.jpg</p>
</blockquote>
<p>先上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv2.bitwise_and(img,img,mask = detected_edges)</span><br></pre></td></tr></table></figure>
<p>同样是Opencv的函数，原理其实是对像素点进行“与”运算。<br>在这里detected_edges图像上只有黑色和白色，它作为蒙版后，其下的img图片对应白色的地方就可以保留，对应黑色的部分就会被遮盖。<br>之前生成的边缘图就是一个只有黑白两种颜色的图啊，如果将边缘图的阈值调的很低，作为蒙版去处理原图。就会得到一个有意思的效果。</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/6110cb519e84e.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">同样建议点开放大看</div>
</center>

<p>借此，就出现了一大批有关的图像处理函数。<br>用这些函数可以做很多P图的工作，比如将上图中的黑色镂空部分换成白色：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/6110e016b9436.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">从刮刮乐变成了彩铅~</div>
</center>

<p>这些函数别人的博客都将的很清楚了，我就不赘述了。<br><a href="https://www.cnblogs.com/ckAng/p/10843409.html">一堆函数</a> ，<a href="https://blog.csdn.net/weixin_35732969/article/details/83748054">以及用这些函数P图的实例</a></p>
<p>于是我就发现我昨天自己写的二值图算法和融合算法完全可以由这些函数代替。那种逐个像素点比对的方式运行速度很慢，我点击运行之后要等上10秒左右才能运行完一张图，完全比不上Opencv里边那些封装好的、高度优化的函数。小丑竟是我自己。<br>这些不能算是今天的重点，今天的重点是动态调参~</p>
<h2 id="cv2-createTrackbar"><a href="#cv2-createTrackbar" class="headerlink" title="cv2.createTrackbar"></a>cv2.createTrackbar</h2><p>直接上代码吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.lib.shape_base <span class="keyword">import</span> dstack</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;D:\Program doc\VScode\VS-code-py\PictureEdge/red.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CannyThreshold</span>(<span class="params">lowThreshold</span>):</span></span><br><span class="line">    detected_edges = cv2.GaussianBlur(gray,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">    detected_edges = cv2.Canny(detected_edges,lowThreshold,lowThreshold*ratio,apertureSize = kernel_size)</span><br><span class="line">    dst = cv2.bitwise_and(img,img,mask = detected_edges)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;canny demo&#x27;</span>,dst)</span><br><span class="line">    <span class="comment">#cv2.imwrite(&#x27;coloredgew.jpg&#x27;,dst)</span></span><br><span class="line"> </span><br><span class="line">lowThreshold = <span class="number">0</span></span><br><span class="line">max_lowThreshold = <span class="number">100</span></span><br><span class="line">ratio = <span class="number">3</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;canny demo&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cv2.createTrackbar(<span class="string">&#x27;Min threshold&#x27;</span>,<span class="string">&#x27;canny demo&#x27;</span>,lowThreshold, max_lowThreshold, CannyThreshold)</span><br><span class="line"> </span><br><span class="line">CannyThreshold(<span class="number">0</span>)  <span class="comment"># initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>感谢<a href="https://blog.csdn.net/sunny2038/article/details/9202641">原文</a>博主</p>
<blockquote>
<p>这里使用的显示窗口不是之前matplot的那一套。这里用的这一套有一点不舒服就是显示出来图像的大小是与显示屏分辨率挂钩的，也就是如果图片的分辨率大于显示屏的分辨率，就会生成一个超大的、超出屏幕的窗口，而且还无法放缩·····</p>
</blockquote>
<p>这里用到了Python函数的定义，而且这里还是回调函数。作用有点像嵌入式里面的服务函数。<br>这个cv2.createTrackbar函数就像是创建了一个外部中断，只要检测到滑块运动了，就会执行回调函数内的语句。后面的代码还在向后运行，不会受这个函数影响（最多就是在回调函数运行时被打断一下而已）</p>
<p>将代码中的cv2.imwrite(‘coloredgew.jpg’,dst)的注释去掉，就可以实时在文件夹中生成你在窗口里看到的图像文件了。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Deal with Markdowm!!</title>
    <url>/2021/08/08/dealwithMD/</url>
    <content><![CDATA[<!-- vscode-markdown-toc -->
<ul>
<li><ol>
<li><a href="#">基础文本效果</a></li>
</ol>
<ul>
<li>1.1. <a href="#-1">文本排版</a></li>
<li>1.2. <a href="#-1">位置、颜色、大小</a></li>
<li>1.3. <a href="#-1">特殊文字效果</a></li>
<li>1.4. <a href="#-1">文字折叠</a></li>
</ul>
</li>
<li><ol start="2">
<li><a href="#-1">基础图片</a></li>
</ol>
<ul>
<li>2.1. <a href="#-1">最普通</a></li>
<li>2.2. <a href="#-1">控制大小</a></li>
<li>2.3. <a href="#-1">多张图片排版</a></li>
</ul>
</li>
<li><ol start="3">
<li><a href="#-1">特殊图片</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
    numbering=true
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="1-基础文本效果"><a href="#1-基础文本效果" class="headerlink" title="1. 基础文本效果"></a>1. <a name=''></a>基础文本效果</h2><h3 id="1-1-文本排版"><a href="#1-1-文本排版" class="headerlink" title="1.1. 文本排版"></a>1.1. <a name='-1'></a>文本排版</h3><p>首行缩进：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&amp;ensp;Lapland</span><br><span class="line">&amp;#8194;拉普兰德</span><br><span class="line">&amp;emsp;Texas</span><br><span class="line">&amp;#8195;德克萨斯</span><br><span class="line">&amp;nbsp;ohohohoh</span><br><span class="line">&amp;#160;awsl</span><br></pre></td></tr></table></figure>
<p>效果：(注意要与上下的文本分开)</p>
<p>&ensp;Lapland</p>
<p>&#8194;拉普兰德</p>
<p>&emsp;Texas</p>
<p>&#8195;德克萨斯</p>
<p>&nbsp;ohohohoh</p>
<p>&#160;awsl</p>
<h3 id="1-2-位置、颜色、大小"><a href="#1-2-位置、颜色、大小" class="headerlink" title="1.2. 位置、颜色、大小"></a>1.2. <a name='-1'></a>位置、颜色、大小</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span> <span class="attr">style</span>=<span class="string">&#x27;color:black;&#x27;</span>&gt;</span></span> 看“板”娘——雷蛇小姐 <span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span> <span class="attr">style</span>=<span class="string">&#x27;color:blue;&#x27;</span>&gt;</span></span> 看“板”娘——雷蛇小姐 <span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">left</span> <span class="attr">style</span>=<span class="string">&#x27;color:blue;&#x27;</span>&gt;</span></span> 看“板”娘——雷蛇小姐 <span class="xml"><span class="tag">&lt;/<span class="name">left</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">sup</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span>看“板”娘<span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>——雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">sub</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span>看“板”娘<span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>——雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span></span><br><span class="line">看“板”娘<span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span> 雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span></span>看“板”娘<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>雷蛇小姐</span><br><span class="line">看“板”娘 <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line">看“板”娘 <span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<center style='color:black;'> 看“板”娘——雷蛇小姐 </center>

<center style='color:blue;'> 看“板”娘——雷蛇小姐 </center>

<p><left style='color:green;'> 看“板”娘——雷蛇小姐 </left></p>
<p><sup><strong>看“板”娘</strong>——雷蛇小姐</sup></p>
<p><sub><strong>看“板”娘</strong>——雷蛇小姐</sub></p>
<p>看“板”娘<b> 雷蛇小姐</b></p>
<p><i>看“板”娘</i>雷蛇小姐</p>
<p>看“板”娘 <em>雷蛇小姐</em></p>
<p>看“板”娘 <br>雷蛇小姐</br></p>
<p>（很多效果都不怎么明显，还有一些没有用）</p>
<h3 id="1-3-特殊文字效果"><a href="#1-3-特殊文字效果" class="headerlink" title="1.3. 特殊文字效果"></a>1.3. <a name='-1'></a>特殊文字效果</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span> 看“板”娘 <span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 雷蛇小姐</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：<br><kbd> 看“板”娘 </kbd> 雷蛇小姐<br>（你要相信这里是个键盘的形状······）</p>
<h3 id="1-4-文字折叠"><a href="#1-4-文字折叠" class="headerlink" title="1.4. 文字折叠"></a>1.4. <a name='-1'></a>文字折叠</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>看“板”娘<span class="xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">雷蛇小姐</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<details>
<summary>看“板”娘</summary>
雷蛇小姐
</details>



<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="2-基础图片"><a href="#2-基础图片" class="headerlink" title="2. 基础图片"></a>2. <a name='-1'></a>基础图片</h2><h3 id="2-1-最普通"><a href="#2-1-最普通" class="headerlink" title="2.1. 最普通"></a>2.1. <a name='-1'></a>最普通</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">雷蛇小姐</span>](<span class="link">https://z3.ax1x.com/2021/08/22/fzXfp9.png</span>)</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://z3.ax1x.com/2021/08/22/fzXfp9.png" alt="雷蛇小姐"></p>
<h3 id="2-2-控制大小"><a href="#2-2-控制大小" class="headerlink" title="2.2. 控制大小"></a>2.2. <a name='-1'></a>控制大小</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://z3.ax1x.com/2021/08/22/fzXfp9.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40%&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://z3.ax1x.com/2021/08/22/fzXfp9.png" width="40%" alt=""/></p>
<h3 id="2-3-多张图片排版"><a href="#2-3-多张图片排版" class="headerlink" title="2.3. 多张图片排版"></a>2.3. <a name='-1'></a>多张图片排版</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://z3.ax1x.com/2021/08/22/hpLMh4.png&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> &gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://z3.ax1x.com/2021/08/22/fzXfp9.png&quot;</span> <span class="attr">height</span>=<span class="string">&quot;80px&quot;</span> &gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<div align="center">

<p><img src="https://z3.ax1x.com/2021/08/22/hpLMh4.png" width="40%" ><img src="https://z3.ax1x.com/2021/08/22/fzXfp9.png" width="40%"></p>
</div>

<h2 id="3-特殊图片"><a href="#3-特殊图片" class="headerlink" title="3. 特殊图片"></a>3. <a name='-1'></a>特殊图片</h2><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">src</span>=<span class="string">&quot;https://z3.ax1x.com/2021/08/22/fzXfp9.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40%&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">display: inline-block;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">color: #999;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">padding: 2px;&quot;</span>&gt;</span></span>看“板”娘——雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzXfp9.png" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">看“板”娘——雷蛇小姐</div>
</center>

]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>When I Went Home</title>
    <url>/2021/08/04/wenthome/</url>
    <content><![CDATA[<h2 id="到家了，真不错"><a href="#到家了，真不错" class="headerlink" title="到家了，真不错~"></a>到家了，真不错~</h2>]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title>制作FOC驱动器（持续更新）</title>
    <url>/2021/08/09/FOCtry/</url>
    <content><![CDATA[<h1 id="Field-Oriented-Control"><a href="#Field-Oriented-Control" class="headerlink" title="Field-Oriented Control"></a>Field-Oriented Control</h1><sup>
    <left style='color:gray;'> 注：BGM《更澜影》~（左上角） </left>
</sup>

<blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>回到家将近一个星期了，头两天做了个略显草率的电源板，因为实在是为了准备一下电赛嘛。趁着电源板没有到货，摸了摸Python的图像处理，现在也感觉差不多了。想起来之前老师说的立创上有电赛相关的内容。看到一个有关Odrive的，貌似是根据成熟的固件做的一套PCB。继续往下翻看到参考文献，发现有稚晖君的文章，毫不犹豫的点进去之后，发现是那篇关于<em><strong>FOC的知乎</strong></em>。看得我热血澎湃。不过，一个现在连在一块新单片机上配置脉冲计数都困难的我来讲，要复现绝非易事，但我还是要尝试一下~~</p>
</blockquote>
<!-- vscode-markdown-toc -->
<ul>
<li><a href="#FOChttps:zhuanlan.zhihu.comp147659820">先将 <a href="https://zhuanlan.zhihu.com/p/147659820">稚晖君FOC神文</a> 供在这里</a></li>
<li><a href="#">规划</a><ul>
<li><a href="#C">C单片机基础功能</a></li>
<li><a href="#D">D功率与逻辑电路</a></li>
<li><a href="#O">O外设</a></li>
<li><a href="#A">A算法</a></li>
<li><a href="#G">G当前进度</a></li>
</ul>
</li>
<li><a href="#D.">D.功率与逻辑电路</a><ul>
<li><a href="#chat">闲谈(chat)</a></li>
<li><a href="#schematicdiagramoverview">原理图概述(schematic diagram overview)</a><ul>
<li><a href="#powersource">电源(power source)</a></li>
<li><a href="#Hallsignal">霍尔信号(Hall signal)</a></li>
<li><a href="#currentsampling">电流采样运放(current sampling)</a></li>
<li><a href="#girddriver">栅极驱动(gird driver)</a></li>
<li><a href="#H-bridgeinverter">逆变全桥(H-bridge inverter)</a></li>
</ul>
</li>
<li><a href="#mentalityofdesigning">设计思路(mentality of designing)</a></li>
</ul>
</li>
</ul>
<!-- vscode-markdown-toc-config
    numbering=false
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

<center style='color:black;'> 

<h2 id="先将-稚晖君FOC神文-供在这里"><a href="#先将-稚晖君FOC神文-供在这里" class="headerlink" title="先将 稚晖君FOC神文 供在这里"></a><a name='FOChttps:zhuanlan.zhihu.comp147659820'></a>先将 <a href="https://zhuanlan.zhihu.com/p/147659820">稚晖君FOC神文</a> 供在这里</h2></center>

<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a><a name=''></a>规划</h2><p>我打算实现的是无刷电机带编码器的版本。虽然听说了无刷电机的无感控制，我还是感觉有感的简单易懂一些。</p>
<h3 id="C单片机基础功能"><a href="#C单片机基础功能" class="headerlink" title="C单片机基础功能"></a><a name='C'></a>C单片机基础功能</h3><p>FOC需要大量的数学计算，因此一块趁手的单片机比较重要。做车用的单片机是英飞凌的TC264，用那块单片机的话很多事都不用愁了，像什么PWM输出，编码器，ADC都是现成的。无奈放假逃离学校的时候什么都拿了，唯独忘了那几片单片机。手头上只有几片32的开发板。<br>初步计划用那F103C8T6，早晚都要会的</p>
<h3 id="D功率与逻辑电路"><a href="#D功率与逻辑电路" class="headerlink" title="D功率与逻辑电路"></a><a name='D'></a>D功率与逻辑电路</h3><p>仔细看了稚晖君的文章，在功率电路上不是很复杂，感觉用半桥驱动器可以实现。之前用IR2104搭H桥，这里不过是搭了一个三相的嘛（？<br>至于电流检测，文章中也提到了采样电阻和霍尔传感器两种方法，复现就行了。</p>
<h3 id="O外设"><a href="#O外设" class="headerlink" title="O外设"></a><a name='O'></a>O外设</h3><p>买一个编码器在C8T6上运行，串级PID三环，速度环和位置环都需要编码器的参与。<br>其次为了显示参数，需要一块屏幕。</p>
<h3 id="A算法"><a href="#A算法" class="headerlink" title="A算法"></a><a name='A'></a>A算法</h3><p>软件要实现大量的数学计算，文章的中描述的倒是能看懂。不过有些操作还是需要依靠单片机的外设实现，比如配置一个并非规律的占空比输出，我目前就没有头绪(莫非用IO口模拟？就算是这样也很不好写啊)<br>总之算法边走边看吧。</p>
<hr>
<h3 id="G当前进度"><a href="#G当前进度" class="headerlink" title="G当前进度"></a><a name='G'></a>G当前进度</h3><p><strong>2021/8/12</strong><br>学习了一段时间Cube,用Cube做GPIO,ADC,UART都挺容易的，无奈没有调试工具，只有一块32ZET6的板子上自带了USB转TTL，好歹能做到数据收发。又花了一些时间在RTT上，但是最终没能将程序融进去，各种头文件乱飞，不是没定义就是重复定义。还是放弃RTT了，我做一个电机驱动也用不到那玩意。<br>买了一些调试工具和屏幕，等到了再继续吧。<br><strong>2021/8/20</strong><br>无刷电驱板设计完成，打板和元件还没到货。</p>
<hr>
<h2 id="D-功率与逻辑电路"><a href="#D-功率与逻辑电路" class="headerlink" title="D.功率与逻辑电路"></a><a name='D.'></a>D.功率与逻辑电路</h2><blockquote>
<h2 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h2><p>花了将近一个星期搜集各种资料，完成了无刷电驱功率与逻辑电路的设计）。打算采取的方案没有变化，驱动的电机是裸电机带霍尔传感器的，这种电机带有8根线，具体详见<a href="https://sheep200.github.io/2021/08/12/Samplingresistance/">采样电阻测电流</a>。这个电驱几乎完成了硬件上要解决的大部分功能，直接接上核心板就可以完成功能（还需要核心板上连编码器）。可以适配软件上的不同方案，达到学习算法的目的。面积是8cmX6cm，面积不大的代价就是元件排布尤为密集以至于不得不使用4层板（反正嘉立创免费），画四层板的方法还是PCB画到一半画不下去了，到B站现学的。</p>
</blockquote>
<p>板子布完线的样子：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/61205b70b2a38.jpg" width="70%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">第一次做四层板</div>
</center>

<h3 id="闲谈-chat"><a href="#闲谈-chat" class="headerlink" title="闲谈(chat)"></a><a name='chat'></a>闲谈(chat)</h3><p>我做的这个这块板子上不自带主控芯片，并且只能驱动一个无刷电机（关于为什么稚晖君能在跟我差不多大的板子上集成主控芯片，屏幕，同时驱动两个无刷电机和两个舵机你自己去问他啊！）不过有一说一，立创上确实找到过一种芯片，drv系列的，这种芯片就是专门的无刷电机驱动芯片。与那种高度集成的功率芯片不同，这种芯片仅集成了逻辑电路部分，功率部分还是采用外置的MOS管之类的，但是重要的是，它的集成度很高，一块1.5cm长的drv8301集成了3个栅极驱动芯片和两路的电流感应放大，这已经能满足驱动一个无刷电机的电流采集要求和栅极驱动要求了，并且有的这种芯片是可以5V供电的，也就是说，它还内置了一个DCDC升压电源用来驱动MOS管。这个系列还有很多版本，长的都跟单片机差不多，但他们都有一个特点，就是根本没货。但我想，这种芯片肯定有替代型号，或者淘宝上也会有，瞄到一眼稚晖君的原理图，他肯定是用了类似的芯片的。</p>
<h3 id="原理图概述-schematic-diagram-overview"><a href="#原理图概述-schematic-diagram-overview" class="headerlink" title="原理图概述(schematic diagram overview)"></a><a name='schematicdiagramoverview'></a>原理图概述(schematic diagram overview)</h3><p>简要描述一下我东拼西凑的一套方案吧，虽然板子还没有打出来测试，但是原理图还是可以说说的。</p>
<h4 id="电源-power-source"><a href="#电源-power-source" class="headerlink" title="电源(power source)"></a><a name='powersource'></a>电源(power source)</h4><p>见图：</p>
<center>
<img src="https://www.hualigs.cn/image/61206d741d9f8.jpg" width="40%" alt=""/>
</center>

<p>没什么好说的，就是模拟电路的滤波电容由条件可以换成钽电容（我这里只有3.3V-A用了钽电容），数字电路一般就没有必要了，钽电容虽然纹波小一些，但对这种电路来讲没太大必要（而且钽电容很贵，那是几十倍的贵啊）<br>这里还用到了一个电压基准芯片，给运放提供基准电压的，用来实现采样电流的双向检测（当ADC采集到的电压高于基准电压时为正，小于基准电压时为负）</p>
<h4 id="霍尔信号-Hall-signal"><a href="#霍尔信号-Hall-signal" class="headerlink" title="霍尔信号(Hall signal)"></a><a name='Hallsignal'></a>霍尔信号(Hall signal)</h4><p>见图：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzXhlR.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">霍尔信号</div>
</center>

<p>这电路一看，其实对信号没有处理，钳了个位基本上就送去单片机了。左边电机处返回的应该是开关的数字信号，直接用GPIO就可，这里的供电适配两种方案，主要是看电机上的霍尔元件的供电电压，选择3.3V或者是5V.</p>
<h4 id="电流采样运放-current-sampling"><a href="#电流采样运放-current-sampling" class="headerlink" title="电流采样运放(current sampling)"></a><a name='currentsampling'></a>电流采样运放(current sampling)</h4><center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzXywT.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">电流采样运放</div>
</center>

<p>图中的这部分共有四组。<br>这里其实我考虑了很多的方案，最后还是选择了这个直接用运放拼的方法。立创上有很多电流感应放大器，他们都有固定的Gain值，直接选就行，价格便宜，外围电路少。但是唯一的缺点就是我找不到双向电流都能检测的电流感应放大器，其中有一款芯片手册中提到了双向检测的方法。就像下图这样：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzX2Y4.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">左下角的“Bidirectional Application”</div>
</center>

<p>这TM不就是把两块芯片正反各接一个吗，这也太简单粗暴了。要是单纯的简单粗暴还好，但是注意这个方案是需要占用两个单片机ADC资源的，有点浪费。<br>况且，电流感应放大器的内部原理就是一个固定放大倍数的运放系统，不需要你配电阻了，节省空间和成本而已。用运放搭是完全没问题的。<br>于是最后就用了上面的直接运放拼的方法。后面的运放做了一个跟随，而且焊上了一个0R电阻，方便以后方案改动需要提高放大倍数时，将0R电阻替换成有阻值的电阻就可以二级放大了。</p>
<h4 id="栅极驱动-gird-driver"><a href="#栅极驱动-gird-driver" class="headerlink" title="栅极驱动(gird driver)"></a><a name='girddriver'></a>栅极驱动(gird driver)</h4><center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzX6TU.jpg" width="80%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">栅极驱动</div>
</center>

<p>本来觉得常见的这种栅极驱动的封装没有那种集成电路的感觉，有点上世纪（话说目前用到的这些都挺上世纪的），就想换一个，比如下面这种：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzXsmV.jpg" width="60%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">小巧 美观 令人爱不释手</div>
</center>

<p>无奈，这种芯片的价格比较贵，而且性能还比传统的2104芯片差一大截，最终还是妥协了。<br>话说回来，在回看EG2104芯片手册的时候我才发现为什么我原来放英飞凌的IR2104的位置放上EG2104就不能用了。这种芯片实际上有两个信号输入脚，SD也是可以输入控制信号完成一些事情的，但我们习惯上把它作为使能引脚并将其无情置高，IR2104这个引脚的高电平容忍度达到了20V吧。但是EG2104就比较低（毕竟没有人会用那么大的信号电压对吧），原来的电路中，我直接将12V接到了SD引脚上，IR2104可以工作，但是EG2104就被这个引脚烧坏了。</p>
<h4 id="逆变全桥-H-bridge-inverter"><a href="#逆变全桥-H-bridge-inverter" class="headerlink" title="逆变全桥(H-bridge inverter)"></a><a name='H-bridgeinverter'></a>逆变全桥(H-bridge inverter)</h4><center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzXRfJ.jpg" width="60%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">就是三个半桥</div>
</center>

<p>也是根普通的H桥驱动直流电机差不多。<br>这里有三相电压的ADC采集以及电源电压的采集，有普通的三相电流采集，还有一个总电流采集。主要是给一些提升空间和容错率，算法好的话，只用一个总电流采集就能达到效果。<br>剩下的就是接口、指示灯什么的，这块板子要向主控接的线足足有16根之多（还包括对主控进行供电）果然稚晖君将所有东西画在一块板子上是明智且高超的。</p>
<h3 id="设计思路-mentality-of-designing"><a href="#设计思路-mentality-of-designing" class="headerlink" title="设计思路(mentality of designing)"></a><a name='mentalityofdesigning'></a>设计思路(mentality of designing)</h3><p>感谢学长赐予的Xmind破解版（雾），思路基本上就是用Xmind和onenote整理出来的，这里斗胆放一下我的Xmind思维导图。</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://z3.ax1x.com/2021/08/22/fzjyjI.jpg" width="80%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">挺乱的······</div>
</center>

<p>新人设计，多多包涵~</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>FOC</tag>
        <tag>MCCM</tag>
      </tags>
  </entry>
  <entry>
    <title>学Cube,走向懒狗人生</title>
    <url>/2021/08/11/STM32Cube/</url>
    <content><![CDATA[<h1 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>要做FOC，我对自己差多少东西还是有点数的。单片机都没怎么学通，别说寄存器了，就连一块32的芯片用Cube写都不熟悉，完全一副被例程惯坏了的样子。从最基础的开始学有一些来不及了，既然打算用手上的这一块C8T6，就直接用Cube写就行了。昨天已经烧进去程序了，现在就是学习如何调通各个外设和模块的事了。</p>
</blockquote>
<h2 id="Cube点亮LED"><a href="#Cube点亮LED" class="headerlink" title="Cube点亮LED"></a>Cube点亮LED</h2><p>1.设置使用外部晶振<br>2.设置时钟树参数<br>3.设置SYS的Debug模式<br>4.在芯片图上找到引脚，配置成GPIO输出<br>5.左边GPIO配置：初始电平、输出模式、上拉下拉，频率，引脚标签<br>6.工程配置：起名，工程文件夹，使用的编译软件，是否复制所有库文件，.c.h分开<br>7.生成工程<br>8.配置下载器<br>9.调用函数<br>10.下载</p>
<h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>得益于STM32的定时器中有编码器的设定，大多数时候都只需要按照顺序调用标准库函数即可。<br>参考<a href="https://blog.csdn.net/lushoumin/article/details/87366618">通用定时器编码器模式</a>，对Cube生成的额代码进行了讲解，Cube配置的方法也在里面了。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>MCCM</tag>
      </tags>
  </entry>
  <entry>
    <title>采样电阻测电流</title>
    <url>/2021/08/12/Samplingresistance/</url>
    <content><![CDATA[<h1 id="采样电阻测电流"><a href="#采样电阻测电流" class="headerlink" title="采样电阻测电流"></a>采样电阻测电流</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>电流检测是FOC必不可少的东西，主流的电流检测一般是霍尔元件和采样电阻。然后我发现一个最便宜的霍尔元件就30++人民币，而且还需要正负15V供电（这也更加印证了电源板的失败。呸，没有正负15V还敢叫电源板？！）。我有这闲工夫闲钱配电源买原元件，不如做一个更亲民的采样电阻检测法了。</p>
</blockquote>
<blockquote>
<p>AD未动，淘宝先行。在淘宝上搜索了霍尔元件测电流的模块，随之找到了上面的霍尔芯片，大部分是ACS712系列的，大约20块钱一片，如果直接从淘宝上买的话，一个30A的ACS712检测模块只要13块钱，虽然精度看评论比较差（有一说一立创贵的离谱，单片机也属他家的最贵）。我动摇了，打算先买个检测模块回来玩玩。关于采样电阻法，打算将理论完成，具体是否在板子上采取这种方案就另作考虑。</p>
</blockquote>
<h2 id="方案综述（全是干货）"><a href="#方案综述（全是干货）" class="headerlink" title="方案综述（全是干货）"></a>方案综述（全是干货）</h2><p>针对FOC来讲,通用的方式就是使用在下桥的后端使用采样电阻进行电流的采样。大佬一般在讨论具体使用1个、2个还是3个的问题，而我就没有这种疑问了（理直气壮）。具体想探讨一下究竟用多少个采样电阻合适请移驾这篇<a href="https://zhuanlan.zhihu.com/p/357517561">知乎文章</a><br>之前没有考虑到无刷电机上的霍尔元件的问题。即便强如稚晖君，使用的也是带有霍尔元件的无刷电机，这种电机的特点就是具有8个引脚（三相电机线，三路霍尔信号线，5V供电，GND）。这里的霍尔元件与测电流的“霍尔元件”不是一个概念。这里的霍尔元件一般被称为霍尔传感器或者霍尔开关，直接装在无刷电机上，用于返回当前无刷电机的定子与转子的相对位置，主要为驱动器上下桥状态的切换提供依据。我在一个<a href="http://www.constarmotor.com.cn/newsinfo/6171.html">页面精美的网站</a>找到了下面这些：</p>
<blockquote>
<p>无刷电机带霍尔传感器的优点：<br> 　1、内装有霍尔传感器，能够检测到转子的位置，启动平稳;<br>　　2、电机可以零速度启动归功与霍尔传感器。<br>　　缺点：<br>　　1、价格比无霍尔的高;<br>　　2、构造比无霍尔的复杂。<br>　　无刷电机无霍尔的优点：<br>　　1.寿命和可靠性更长，因为没有霍尔可以损坏;<br>　　2.成本低，因为不用霍尔，更不用霍尔支架。<br>　　3.制造更简单，传统电机需要调整霍尔角度。<br>　  缺点：<br>　　1.启动不流畅，因没有霍尔检测转子位置，因此驱动部分需要做过零点电流检测，导致电机启动时震动，甚至无法启动;<br>　　2.不适合大负载或负载变化大的场合应用;<br>　　3.有霍尔驱动器无法驱动此种电机。</p>
</blockquote>
<p>反正就是带霍尔的无刷电机yyds<br>稚晖君的<a href="https://www.bilibili.com/video/BV11V41127pq">FOC视频</a>下面有一楼大佬的评论（淹没在一众膜拜之声中（大雾）），讨论稚晖君的位置传感方式，其中有提到根据电流的高精度检测和反电动势计算，配合霍尔传感器就可以做到不用编码器实现电机转子的位置返回，有兴趣的可以去翻翻。至于晖君哥用的是哪种，我记得他在哪里说过没有用编码器来着。<br>回到采样电阻上来~之前说到要使用三个采样电阻，直接对三路的电流进行采集。采样电阻有专门的放大器可以用，立创上搜“电流感应放大器”就有了，相当于里面集成了一个固定放大倍数的运放系统，自己搭运放也没有问题。电路很好搭，唯一的问题就是双向检测。在立创的开源平台上也有人做这个，用的集成过的芯片，工程名称叫“双向电流检测模块”，无奈上面的接口有点多，出现很多个0R电阻，有点云里雾里的。还有一种方案，是在MAX9938系列芯片的芯片手册里看到的，好家伙，在同一个采样电阻上正着、反着各接了一个同样的芯片，最后占用了两个ADC的口，分别输出正向和反向的电流······从淘宝上看到的霍尔元件检测电流的模块，返回的ADC的值存在一个中值，高于这个值为正，低于这个值为负。这多方便啊，无奈评论区说这样检测精度比较低，而且也没有看到有人在无刷电机的控制上使用霍尔元件检测电流的(我原先还把电机上的霍尔元件跟这个检测电流的元件弄混了)。在这些电流感应放大器中，有一些是需要基准电压的，一般叫Vref，还有一些连单独供电都不需要。那个基准电压的产生还需要一种叫做“<a href="http://www.elecfans.com/dianzichangshi/20180129625382.html">电压基准芯片</a>”的东西产生。关于为什么有些芯片需要这个基准电压我还没有弄明白，不过好像对双向检测有帮助。<br>还有一种直接用<a href="http://www.xjishu.com/zhuanli/52/201821212436.html">运放搭双向电路的方案</a>,这里面有电路图，但是解释的文字被折叠了，姑且放在这里吧。<br>下面研究一下PCB布局和滤波元器件的问题。<br>PCB布局和元件选型参考CSDN上的<a href="https://blog.csdn.net/geek_monkey/article/details/104856007">开尔文接法</a><br>关于滤波元件，如果元件手册给的不详细的话，就只能自己装一些了。由于还没有学模电，还是需要科普一下<a href="https://baike.sogou.com/v4320416.htm?fromTitle=%E5%85%B1%E6%A8%A1%E6%8A%91%E5%88%B6%E6%AF%94">共模抑制</a>与差模抑制。这部分的资料还没有找全，以后再说吧。<br>在算法上，FOC电流采样的时机考虑到各种时延需要延后，见<a href="https://blog.csdn.net/u010632165/article/details/104558329">FOC采样不准</a></p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>FOC</tag>
        <tag>BLDC</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础学习</title>
    <url>/2021/08/26/pythonlearnsum/</url>
    <content><![CDATA[<!-- vscode-markdown-toc -->
<ul>
<li><a href="#PivotGrammar">基础语法Pivot Grammar</a></li>
<li><a href="#Library">库Library</a><ul>
<li><a href="#Pandas">Pandas</a></li>
<li><a href="#glob">glob</a></li>
</ul>
</li>
<li><a href="#else">其他else</a></li>
</ul>
<!-- vscode-markdown-toc-config
    numbering=false
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


<sup>
    <left style='color:gray;'> 注：BGM《Till the Bell Tolls》~（左上角） </left>
</sup>

<blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>大一暑假还余了几天，画完了FOC板子之后，本应该继续学习单片机程序，好做出真正的FOC控制来。但是一来有一些开学前的事情要处理，比如志愿活动巴拉巴拉，另外一方面就是懒了，觉得在家没有什么设备，各种功能测试起来都非常地麻烦。况且，如果不用32的单片机做控制核心的话，TC264和TC364的底层都是现成的。既然如此，何不用剩下的时间弄点有意思的事情呢？好巧不巧，前两天在为新生硬件考核做准备的时候，接触到了用python处理excle自动批改试卷的程序。我就有趁此机会学学python，拿这个程序练手。</p>
</blockquote>
<p>我感觉上，Python学完基础语法之后就可以开始看库了。库应当是Python程序中非常重要的东西。所以接下来也会涉及到各种库，会比较表面就是了······</p>
<h2 id="基础语法Pivot-Grammar"><a href="#基础语法Pivot-Grammar" class="headerlink" title="基础语法Pivot Grammar"></a><a name='PivotGrammar'></a>基础语法Pivot Grammar</h2><p>不需要我多说，网上早有非常详尽的<a href="https://www.runoob.com/python/python-basic-syntax.html">Python基础语法教程</a><br>Python确实根C语言大不相同。</p>
<h2 id="库Library"><a href="#库Library" class="headerlink" title="库Library"></a><a name='Library'></a>库Library</h2><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a><a name='Pandas'></a>Pandas</h3><p>简单来说，Pandas是用来处理关系型，标记型数据的。这里用它的函数来处理excel</p>
<p>Pandas有自己的<a href="https://www.pypandas.cn/docs/getting_started/">Pandas中文网</a>，上面也有比较详细的讲解。不过要查单个函数的作用，其实我还是推荐直接上网查函数名，有时候会更易懂一些。</p>
<h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a><a name='glob'></a>glob</h3><p>glob是Python下自带的文件操作模块，用它可以查找符合自己目的的文件，类似于Windows下的文件搜索。<br>使用前需要<code>import glob</code>.<br>1.<a href="https://www.jianshu.com/p/05fc1f66974b">glob.glob()</a><br>作用是将一个文件夹中的符合条件的文件的地址收集起来并返回一个列表。<br>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Answer_Paths = glob.glob(<span class="string">&#x27;AnswerSheet/*.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="其他else"><a href="#其他else" class="headerlink" title="其他else"></a><a name='else'></a>其他else</h2><p><left style='color:green;'> Format函数 </left><br>字符串转换函数，见<a href="https://baike.sogou.com/v469288.htm?fromTitle=Format%E5%87%BD%E6%95%B0">搜狗解释</a><br>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您岛上共有&#123;&#125;位干员&quot;</span>.<span class="built_in">format</span>(able_officer))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在审核&quot;</span>,Name,<span class="string">&quot;的简历&quot;</span>,<span class="string">&quot;当前进度:&#123;&#125;/&#123;&#125;==========&quot;</span>.<span class="built_in">format</span>(officer_Num,Nums))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>BSP RTT学习之旅</title>
    <url>/2021/09/13/rtt-bsp/</url>
    <content><![CDATA[<h1 id="Board-Support-Package-板级支持包"><a href="#Board-Support-Package-板级支持包" class="headerlink" title="Board Support Package 板级支持包"></a>Board Support Package 板级支持包</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>大二开学有将近一周时间了，视觉组的培训在暑假期间就基本结束了，开学这一周主要是电控组培训（然而硬件组培训还是没有任何消息······）<br>电控组培训的大概内容就是：基于RT-thread，驱动一个can设备（要求双向通信，这个can设备其实就是大疆的钞能力电机），并且依据电机返回的电流、转速和位置信息设计串级PID，完成对电机转角的精确控制。看上去很美好，是个人都眼馋，无奈学长提供的硬件不多，而且大疆C板还被弄坏了一个。我好不容易配出来了大疆C板的BSP，刚把程序烧进去，运行试了一下，板子就被软件同学撸走了。别说什么串级PID了，就连调通can设备都困难。于是我一想干脆不跟他们抢了，我配一个自己STM32开发板上能用的BSP自己玩去了。</p>
</blockquote>
<h2 id="RT-thread"><a href="#RT-thread" class="headerlink" title="RT-thread"></a>RT-thread</h2><h3 id="BSP配置"><a href="#BSP配置" class="headerlink" title="BSP配置"></a>BSP配置</h3><p>BSP学长学姐就帮了大忙了，没有那些资料我连RT-thread需要BSP都不知道(我菜死了)······<br>RTT官方已经非常清楚的写出了<a href="https://gitee.com/rtthread/rt-thread/tree/gitee_master/bsp/stm32/docs">BSP的配置方法</a>了。参数的设置要根据单片机的型号来确定，最典型的就是Flash大小和sram大小。这两个参数还涉及到地址的起始点的问题，RTT默认的起始位置我用起来也就没问题。<br>关于大疆C板的配置的方法有一个单独的文档，跟RTT的官方文档大同小异，不过这属于实验室的内部资料就不给链接了。<br>除此之外，RTT还有一个<a href="https://www.rt-thread.org/document/site/#/">RT-thread学习文档</a>，主要是为调通外设和线程调度服务的，不过在这里也可以看一下，至少配BSP的时候不会稀里糊涂的。<br>其中需要注意的一点就是单片机外设的配置，比如ADC、PWM之类的，官方文档也写的比较清楚。<br>添加BSP单片机外设时，按照重新生成工程的路子走，然后重新添加一下工程的include路径就行了（也许在样例工程中改好，生成的工程也就不用填了呢？）</p>
<h3 id="Thread创建与调度"><a href="#Thread创建与调度" class="headerlink" title="Thread创建与调度"></a>Thread创建与调度</h3><p>基本上是按照单片机课程上讲解的方法去设置的，基本的调度没出什么差错。具体线程间通信等等还是指路官方文档。<br>但实际上，还是全局变量比较简单好使。</p>
<h2 id="外设-perpheral"><a href="#外设-perpheral" class="headerlink" title="外设-perpheral"></a>外设-perpheral</h2><h3 id="无线串口-uart"><a href="#无线串口-uart" class="headerlink" title="无线串口-uart"></a>无线串口-uart</h3><p>无线串口我是配来发送数据的，后来调电机的时候用这个生成波形图。（但是效果极差，不知道为啥）<br><left style='color:green;'> KEYconfig </left></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuconfig BSP_USING_UART</span><br><span class="line">    bool &quot;Enable UART&quot;</span><br><span class="line">    default y</span><br><span class="line">    select RT_USING_SERIAL</span><br><span class="line">    if BSP_USING_UART</span><br><span class="line">        config BSP_USING_UART4</span><br><span class="line">            bool &quot;Enable UART4&quot;</span><br><span class="line">            default y</span><br><span class="line"></span><br><span class="line">        config BSP_UART4_RX_USING_DMA</span><br><span class="line">            bool &quot;Enable UART4 RX DMA&quot;</span><br><span class="line">            depends on BSP_USING_UART4 &amp;&amp; RT_SERIAL_USING_DMA</span><br><span class="line">            default n</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure>
<h3 id="PWM外设"><a href="#PWM外设" class="headerlink" title="PWM外设"></a>PWM外设</h3><p>用来驱动舵机<br><left style='color:green;'> KEYconfig </left></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuconfig BSP_USING_PWM</span><br><span class="line">    bool &quot;Enable pwm&quot;</span><br><span class="line">    default n</span><br><span class="line">    select RT_USING_PWM</span><br><span class="line">    if BSP_USING_PWM</span><br><span class="line">        menuconfig BSP_USING_PWM1</span><br><span class="line">            bool &quot;Enable timer1 output pwm&quot;</span><br><span class="line">            default n</span><br><span class="line">            if BSP_USING_PWM1</span><br><span class="line">                config BSP_USING_PWM1_CH1</span><br><span class="line">                    bool &quot;Enable PWM1 channel1&quot;</span><br><span class="line">                    default n </span><br><span class="line">            endif</span><br><span class="line">            if BSP_USING_PWM1</span><br><span class="line">                config BSP_USING_PWM1_CH2</span><br><span class="line">                    bool &quot;Enable PWM1 channel2&quot;</span><br><span class="line">                    default n </span><br><span class="line">            endif</span><br><span class="line">            if BSP_USING_PWM1</span><br><span class="line">                config BSP_USING_PWM1_CH3</span><br><span class="line">                    bool &quot;Enable PWM1 channel3&quot;</span><br><span class="line">                    default n </span><br><span class="line">            endif</span><br><span class="line">            if BSP_USING_PWM1</span><br><span class="line">                config BSP_USING_PWM1_CH4</span><br><span class="line">                    bool &quot;Enable PWM1 channel4&quot;</span><br><span class="line">                    default n </span><br><span class="line">            endif</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure>

<h3 id="ADC数模转换器"><a href="#ADC数模转换器" class="headerlink" title="ADC数模转换器"></a>ADC数模转换器</h3><p>没什么好说的，RTT文档里写的很清楚了。<br><left style='color:green;'> KEYconfig </left></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuconfig BSP_USING_ADC</span><br><span class="line">    bool &quot;Enable ADC&quot;</span><br><span class="line">    default n </span><br><span class="line">    select RT_SERIAL_USING_ADC</span><br><span class="line">    if BSP_USING_ADC1</span><br><span class="line">        config BSP_USING_ADC1</span><br><span class="line">            bool &quot;Enable ADC1&quot;</span><br><span class="line">            default n</span><br><span class="line">    endif</span><br><span class="line">    if BSP_USING_ADC2</span><br><span class="line">        config BSP_USING_ADC2</span><br><span class="line">            bool &quot;Enable ADC2&quot;</span><br><span class="line">            default n</span><br><span class="line">    endif         </span><br></pre></td></tr></table></figure>

<h3 id="LCD液晶屏"><a href="#LCD液晶屏" class="headerlink" title="LCD液晶屏"></a>LCD液晶屏</h3><p>使用LCD液晶屏的例程驱动，需要修改其中的delay，而且这个例程的Pin口不太好改，都定义实在了。<br>这个外设不需要KEYconfig，直接将用到的GPIO配置成输入或者输出就行。<br>不过GPIO也是需要配置的。<br><left style='color:green;'> KEYconfig </left></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config BSP_USING_GPIO</span><br><span class="line">    bool &quot;Enable GPIO&quot;</span><br><span class="line">    select RT_USING_PIN</span><br><span class="line">    default y</span><br></pre></td></tr></table></figure>

<h3 id="PS2手柄"><a href="#PS2手柄" class="headerlink" title="PS2手柄"></a>PS2手柄</h3><p>看懂了之后只需要两个文件就可以驱动，需要修改Pin口和高低电平的函数。<br>只不过，这个手柄的性能实在是太差了，反应慢不说，还总是断连，模拟值还不准，动不动就到底了。<br>调参是不太现实的，最多能修改一个状态量。</p>
<h3 id="钞能力CAN电机"><a href="#钞能力CAN电机" class="headerlink" title="钞能力CAN电机"></a>钞能力CAN电机</h3><p>这个主要是CAN通信的配置。<br>CAN通信需要一个外设芯片来处理电平，这个模块淘宝20块钱就可以买到一个不错的，还带有数据收发指示灯。<br>配置流程还是没差，CubeMX,KEYconfig,RTT文档。<br><left style='color:green;'> KEYconfig </left></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuconfig BSP_USING_CAN</span><br><span class="line">    bool &quot;Enable CAN&quot;</span><br><span class="line">    default n</span><br><span class="line">    select RT_USING_CAN</span><br><span class="line">    if BSP_USING_CAN</span><br><span class="line">        config BSP_USING_CAN1</span><br><span class="line">            bool &quot;Enable CAN1&quot;</span><br><span class="line">            default n</span><br><span class="line">    endif  </span><br></pre></td></tr></table></figure>
<p>主要的RTT文档一般是问题比较大的地方，需要创建另一个线程来处理CAN数据的接收，另外CAN在发送的时候格式也限定得死死的。<br>CAN是可以同时与多个设备通信的，好像是说CAN主机向所有设备发送的数据都是一样的，但是接收的时候需要设置硬件过滤表来分辨不同的设备。目前还没有仔细研究过这个东西。<br>这个电机另一个需要注意的地方就是数据格式，发回来的数据是一个8个元素的uint8_t数组，这个数组每两位表示一个short，收回来之后需要进行一个位运算才能变成正常的值。</p>
<h3 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h3><p>我低估了这个玩意，还是有一点难度的。<br>目前只是矩阵按键的Beta1.0版本，能够做到识别矩阵按键当前的状态，但是同一行的矩阵按键不能同时按下，否则这一行什么都识别不到，不同行的按键可以同时按下。<br>下面用代码展示一下实现方法：<br>代码的主要思路就是逐行检测，即将每一行对应的IO设为输出，每一列的IO设为输入。然后轮换输出并检测输入IO的值。利用当前输出IO的序号和当前输入IO的序号确定按下去的按键位置。<br>需要一个定时器来周期性的检测并更新按键当前的状态，使用一个uint16_t来储存16个按键的状态。<br>顺带一提，整体是在RTT中实现的,使用的函数都是RTT的函数。单片机是STM32F103ZET6。程序中作为输入的IO是 PF4到PF7 用于输出的IO是 PF0到PF3（程序中直接用了for来操作引脚）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器回调函数--按键状态更新</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout_keyboard</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span>&#123;</span><br><span class="line">	<span class="keyword">uint16_t</span> key=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;rt_pin_write(LED1_PIN, PIN_HIGH);i=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;rt_pin_write(LED1_PIN, PIN_LOW);i=<span class="number">0</span>;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rt_pin_write(GET_PIN(F, i), PIN_LOW);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(PIN_LOW==rt_pin_read(GET_PIN(F, j+<span class="number">4</span>)))</span><br><span class="line">			&#123;</span><br><span class="line">				key = <span class="number">1</span>;</span><br><span class="line">				KEYboard = KEYboard | key &lt;&lt; (j*<span class="number">4</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				key = <span class="number">1</span>;</span><br><span class="line">				key = key &lt;&lt; (j*<span class="number">4</span>+i);</span><br><span class="line">				KEYboard = KEYboard &amp; (~key);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		rt_pin_write(GET_PIN(F, i), PIN_HIGH);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GPIO的初始化函数如下，这个只需要在主函数中运行一次就行（废话）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*KEYboard GPIO初始化*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SH_KEYboard_GPIO_INIT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	rt_pin_mode(P_KB_1, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">	rt_pin_mode(P_KB_2, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">	rt_pin_mode(P_KB_3, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">	rt_pin_mode(P_KB_4, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">	rt_pin_mode(P_KB_5, PIN_MODE_OUTPUT);</span><br><span class="line">	rt_pin_mode(P_KB_6, PIN_MODE_OUTPUT);</span><br><span class="line">	rt_pin_mode(P_KB_7, PIN_MODE_OUTPUT);</span><br><span class="line">	rt_pin_mode(P_KB_8, PIN_MODE_OUTPUT);</span><br><span class="line">	</span><br><span class="line">	rt_pin_write(P_KB_5, PIN_HIGH);</span><br><span class="line">	rt_pin_write(P_KB_6, PIN_HIGH);</span><br><span class="line">	rt_pin_write(P_KB_7, PIN_HIGH);</span><br><span class="line">	rt_pin_write(P_KB_8, PIN_HIGH);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，为了方便的使用按键，还需要函数对uin16_t进行解码.<br>通过输入按键的X,Y坐标,就可以返回这个按键是否被按下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*KEYboard按键读取*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">SH_KBread</span><span class="params">(<span class="keyword">uint8_t</span> X,<span class="keyword">uint8_t</span> Y,<span class="keyword">uint16_t</span> KBS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint16_t</span> key=<span class="number">0x0001</span>;</span><br><span class="line">	KBS = KBS &gt;&gt; (Y*<span class="number">4</span>+X);</span><br><span class="line">	<span class="keyword">if</span>((KBS&amp;key)==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，为了便于测试按键的作用，需要整体显示一下按键的状态。得益于之前配过一个LCD的显示屏，就在显示屏上显示按键的当前状态吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示KEYboard状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SH_LCDshow_KETboard</span><span class="params">(<span class="keyword">uint16_t</span> KBS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> txt[<span class="number">4</span>][<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">char</span> txt1[<span class="number">16</span>];</span><br><span class="line">	rt_sprintf(txt1,<span class="string">&quot;%d      &quot;</span>,KBS);</span><br><span class="line">	SH_DrawFont_GBK16(<span class="number">16</span>,<span class="number">8</span>,GREEN,GRAY0,txt1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;<span class="number">4</span>;y++)</span><br><span class="line">	&#123;</span><br><span class="line">		rt_sprintf(txt[y],<span class="string">&quot;%d %d %d %d&quot;</span>,</span><br><span class="line">		SH_KBread(<span class="number">0</span>,y,KBS),</span><br><span class="line">		SH_KBread(<span class="number">1</span>,y,KBS),</span><br><span class="line">		SH_KBread(<span class="number">2</span>,y,KBS),</span><br><span class="line">		SH_KBread(<span class="number">3</span>,y,KBS)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;<span class="number">-1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		SH_DrawFont_GBK16(<span class="number">16</span>,(<span class="number">88</span>-i*<span class="number">20</span>),GREEN,GRAY0,txt[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	rt_thread_mdelay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就放在LCD显示线程里调用就行。这里就需要调用刚才写出的函数了。</p>
<p>最终效果如图：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://i.loli.net/2021/09/19/htjfXSQD9E5nWFp.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
-
color: #999;
padding: 2px;">按键板</div>
</center>

<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://i.loli.net/2021/09/19/iOtETp7Fgj31hXw.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">显示效果</div>
</center>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>MCCM</tag>
        <tag>Rt-thread</tag>
        <tag>BSP</tag>
      </tags>
  </entry>
  <entry>
    <title>装机二三事</title>
    <url>/2021/09/21/assemblePC/</url>
    <content><![CDATA[<h1 id="build-our-own-computer"><a href="#build-our-own-computer" class="headerlink" title="build our own computer"></a>build our own computer</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>大二开学俩星期了，想起来寒假结束之时拿家里的垃圾装了两台电脑，还没总结点什么。再加上这个中秋节，在实验室花了两天时间收拾东西，翻出来一块电脑主板。睹物生情，那么就聊聊装机二三事吧~</p>
</blockquote>
<h2 id="识零件"><a href="#识零件" class="headerlink" title="识零件"></a>识零件</h2><p>大体上来讲，装一台电脑需要以下几个东西：电脑主板（带风扇）、CPU，内存、显示器、电源、硬盘（固态、机械）、显卡（看主板可以没有）、光驱（看需求可以没有）、声卡（看需求可以没有）、网卡（一般主板集成）。<br>什么？你问我机箱？要什么机箱？鞋盒不能用吗？！</p>
<p>下面按照装电脑的顺序来逐一介绍各个配件（顺序可供参考）</p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>通用主板一般有两种型号，一种是长方形，有六个固定孔；还有一种几乎为正方形，只有四个固定孔。主办的大小一般影响不是很大，主要还是看上面的接口是否满足需要。</p>
<h4 id="小接口"><a href="#小接口" class="headerlink" title="小接口"></a>小接口</h4><p>为什么称为小接口呢？因为他们很小。<br><b> 主板固定孔 </b><br>一般主板有4种尺寸，M-ATX（紧凑型）、ATX（标准型）、E-ATX（加强型）、MINI-ITX（迷你型）。最常见的就是ATX和M-ATX了，前者为标准的305mm - 244mm ,后者则为边长 244mm 的正方形。分别有6个和4个固定孔。<br>固定孔直接拿螺丝拧上就行，之后所有的操作都只需要一把十字的螺丝刀就搞定。<br>大机箱可以兼容小板子，反之自然不行。<br>还存在尺寸更小的型号以及特制电脑的主板，看上去就跟一块野火探索者大小差不多。不过有一说一，有些厂家生产的“特制电脑”内部结构十分惊艳，可以搭配市面上一些常见的零件的同时空间利用非常紧凑，通风又到位，实属视觉享受。<br>PS：有幸拆过和RM服务器一样的服务器主机，这个就很典型。</p>
<p><b> 主板供电接口 </b><br>主板上会有20针或24针的插槽，用于连接电源为主板供电。一般长下面这个样子。<br><img src="https://i.loli.net/2021/09/23/Xkj6KN3zsphdMiH.jpg" width="40%" alt=""/><br><img src="https://i.loli.net/2021/09/23/SFp7tTYOhgDIxyR.jpg" width="40%" alt=""/></p>
<p>一般24针的主板比较主流，性能高一些。一般的电源两种供电接口都会适配，电源引出的主板供电线会分成两股，一股20针，另一股4针，拼在一起就可以插进24针的槽里了。</p>
<p><b> CPU供电接口 </b><br><img src="https://i.loli.net/2021/09/23/78lTVwWYAHes2xf.jpg" width="40%" alt=""/><br>CPU的功率很大，主板的电压可能吃不消，所以就单独供电了。部分丧心病狂的CPU甚至会给两个CPU供电接口，功率可想而知(大部分CPU运行起来有几十A的电流，部分可以上百)<br><img src="https://i.loli.net/2021/09/23/9iVlasS2t3MCYPg.jpg" width="70%" alt=""/><br>上图中可以看到CPU附近有一排电容和线圈，主要是为CPU这种高频器件的电源滤波的。一般看主板这种电容阵列越壮观越好，并且电容组的质量还会影响到这块主板上CPU的超频能力。</p>
<p><b> 机箱接口 </b><br>机箱上会有什么呢？答案就是开关！（废话）<br>连接机箱最主要的接口就是电源开关（POWER SW），复位开关（常说的重启键 RESET），硬盘指示灯（HD_LED 不知道为什么这个灯的地位这么高······）<br>这是实验室翻出来的那块板子上的接口：<br><img src="https://i.loli.net/2021/09/23/OZAtr6PTRKLqSfC.jpg" width="40%" alt=""/><br>这个接口就负责上面三项。<br>最右边落单的杜邦线不用接，然后剩下8个左右相邻的为一组，左边两组都是硬盘灯（看机箱有几个硬盘灯了，注意LED正负极），右边下面的为复位，右上为电源，这两个没有正负极。</p>
<p>除此之外，机箱为了方便USB设备的使用，会在机箱上设置几个USB接口，以免每次插USB的时候都要跑到机箱后面去。<br><img src="https://i.loli.net/2021/09/23/eU8bnzuLcKBZdh3.jpg" width="60%" alt=""/><br>PS：遇到主板上出现有的排针的针脚消失的情况不要慌张（买回来的新主板当然不会慌张，这句话是对新手垃圾佬说的）消失的针脚是为了防反接的（刚才那个多出来的落单引脚也是同理）</p>
<p>很多机箱还会带有音频口，道理同USB，避免为了插个耳机钻到电脑屁股后面去。<br><img src="https://i.loli.net/2021/09/23/6wbUeOtpnGxDNTa.jpg" width="40%" alt=""/><br>跟USB一样是一整块引线，还有防反接。</p>
<p>部分机箱还带有很多七七八八的功能，比如机箱上自带一个显示屏，而且有CPU温度探头和机箱风扇转速检测，各种参数在显示屏上显示的。这个时候需要把温度探头插到CPU散热片里面，转速检测器与风扇的供电相连（通过电压看转速，前提是机箱上自带的风扇），然后电源需要单独为机箱供电。<br>PS：鄙人家里一台报废的古老客厅电脑的机箱就有这些神奇功能，并且外观是平放在桌子上的，很像早些年的DVD机。</p>
<h4 id="内存插槽"><a href="#内存插槽" class="headerlink" title="内存插槽"></a>内存插槽</h4><img src="https://i.loli.net/2021/09/23/FYLRByQxkW8ej9Z.jpg" width="70%" alt=""/>

<p>内存非常重要，是决定显示屏是否能点亮的两大关键因素之一，另一个是显卡，但这个很少出问题（毕竟显卡的价格不是内存能比的hhhhhhhh）<br>内存经过多次迭代，插槽也有较多种类，不过整体形状没变化太多，只是金手指的分布有些许变化。<br>这样也是为了防止频率相差太多的内存被插上去使用。<br>下面引用一下<a href="https://wenwen.sogou.com/z/q714315215.htm">搜狗问问的回答</a></p>
<blockquote>
<p>主板的内存插槽有：DDR ，DDR2， DDR3 以及目前最新的DDR4类型插槽接口<br>1、DDR是最早的内存，速度慢，功耗大，电压2.5V。DDR400就是一个例子，速度是400mhz<br>2、DDR2是第二代内存，电压1.8V，速度一般都是667或800。<br>3、DDR3是目前最普遍的内存，电压1.5V，速度很快，容量也很大，单条最大可达到8GB，频率从1066-2400mhz不等。<br>4、DDR4是新一代内存，DDR4内存条外观变化明显，金手指变成弯曲状内存频率提升明显，可达4266MHz内存容量提升明显，可达128GB，功耗明显降低，电压达到1.2V、甚至更低。</p>
</blockquote>
<center>
<img src="https://i.loli.net/2021/09/23/6A1nC3GNfDbx5lQ.jpg" width="60%" alt=""/>
</center>

<p><a href="https://zhinan.sogou.com/guide/detail/?id=316512893270">区分不同DDR的方法</a><br>实验室翻出来的主板上的内存插槽是DDR一代，我都没想到这么拉······<br>内存的迭代主要在容量和频率上，容量看需求，但频率不对的内存轻则性能下降，重则无法点亮（skr）<br>内存频率要根据CPU支持的内存频率以及主板支持的频率选择。</p>
<p>内存插槽还需要注意的一点，是主板的内存通道。这个决定你拥有的内存数小于主板插槽数时应该装哪里。<br>直接看这个<a href="https://www.zhihu.com/question/22125087#:~:text=%E4%B8%BB%E6%9D%BF%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%8F%92%E6%A7%BD%E4%B8%80%E8%88%AC%E9%83%BD%E9%87%87%E7%94%A8%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9D%A5%E5%8C%BA%E5%88%86%E5%8F%8C%E9%80%9A%E9%81%93%E4%B8%8E%E5%8D%95%E9%80%9A%E9%81%93%E3%80%82,%E4%BE%8B%E5%A6%82%E4%B8%8A%E5%9B%BE%EF%BC%8C%E5%B0%86%E4%B8%A4%E6%9D%A1%E8%A7%84%E6%A0%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E5%86%85%E5%AD%98%E6%9D%A1%E6%8F%92%E5%85%A5%E5%88%B0%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E7%9A%84%E6%8F%92%E6%A7%BD%E4%B8%AD%EF%BC%8C%E5%8D%B3%E6%89%93%E5%BC%80%E4%BA%86%E5%8F%8C%E9%80%9A%E9%81%93%E5%8A%9F%E8%83%BD%E3%80%82%20%E5%9C%A8%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%8F%92%E6%A7%BD%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%A4%E6%9D%A1%E8%A7%84%E6%A0%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E6%89%93%E5%BC%80%E5%8F%8C%E9%80%9A%E9%81%93%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E3%80%82">知乎</a>的高赞回答吧（为什么知乎网页链接这么长？）</p>
<h4 id="储存介质插槽"><a href="#储存介质插槽" class="headerlink" title="储存介质插槽"></a>储存介质插槽</h4><p>储存介质一般有机械硬盘，光驱，固态硬盘。（一般不考虑软盘啊···）一些接口这三种都是可以通用的，后面会提到。</p>
<p>引用部分介绍来源于<a href="https://zhidao.baidu.com/question/1766434819109878420">百度</a></p>
<p><b> IDE </b></p>
<blockquote>
<p>其英文名称：Integrated Drive Electronics，IDE代表着硬盘的一种类型，但在实际的应用中，人们也习惯用IDE来称呼最早出现IDE类型硬盘ATA-1，这种类型的接口随着接口技术的发展已经被淘汰了。</p>
</blockquote>
<p>幸运的是，我在实验室翻出来的这块主板上找到了这种接口，而且只有这种接口（可见板子之古老）。</p>
<center>
<img src="https://i.loli.net/2021/09/28/7rLn5uH2MGksVWB.jpg" width="60%" alt=""/>
</center>

<p>高达40针的接口，非常的不方便。不过因为光驱的迭代显然比硬盘慢得多，当硬盘普遍使用SATA接口的时候，还有很多光驱使用的是IDE接口，所以现在的电脑主板上还是能见到这种接口的（并非绝对啊，毕竟目前USB光驱已经满天飞了）。</p>
<p><b> SCSI </b></p>
<blockquote>
<p>其英文名称为：Small Computer System Interface。SCSI并不是专门为硬盘设计的接口，是一种广泛应用于小型机上的高速数据传输技术。SCSI接口具有应用范围广、多任务、带宽大、CPU占用率低，以及热插拔等优点。</p>
</blockquote>
<center>
<img src="https://i.loli.net/2021/09/28/RLn5jWZIYb3QDNJ.jpg" width="60%" alt=""/>
</center>

<p>这种接口在家用电脑上很不常见，主要面向服务器和工作站市场。速度、性能和稳定性上都比IDE要好很多，但需要使用专门的SCSI硬盘，价格昂贵。<br>不过这种接口也需要50Pin的线（密度大，所以看起来比较小），且用且珍惜。</p>
<p><b> SATA </b></p>
<blockquote>
<p>其英文名称为：Serial Advanced Technology Attachment。使用SATA（Serial ATA）口的硬盘又叫串口硬盘，是未来PC机硬盘的趋势。Serial ATA采用串行连接方式，串行ATA总线使用嵌入式时钟信号，具备了更强的纠错能力。</p>
</blockquote>
<center>
<img src="https://i.loli.net/2021/09/28/CqOQtFdP3U6GJN9.jpg" width="60%" alt=""/>
</center>

<p>SATA在取代IDE之后，内部也进行了迭代。目前常见的为SATA3、SATA2。有点类似我们常说的USB2.0 和USB3.0 一样，都是可以兼容的，只不过SATA3的传输速度会更快一点。<br>这个接口就明显的比之前的接口体积上小了不少。目前的硬盘大多数都是SATA的接口了，包括一些固态硬盘，但是固态硬盘的御用接口还是PCI-E，这个属于另一种接口，后面再说。</p>
<p><b> SAS </b></p>
<blockquote>
<p>其英文名称为：Serial Attached SCSI。其可以向下兼容SATA。具体来说，二者的兼容性主要体现在物理层和协议层的兼容。<br>在物理层，SAS接口和SATA接口完全兼容，SATA硬盘可以直接使用在SAS的环境中，从接口标准上而言，SATA是SAS的一个子标准，因此SAS控制器可以直接操控SATA硬盘，但是SAS却不能直接使用在SATA的环境中，因为SATA控制器并不能对SAS硬盘进行控制。</p>
</blockquote>
<p>额，找了半天只找到了一张图。</p>
<center>
<img src="https://i.loli.net/2021/09/28/8jaKQpRyHczlYsU.jpg" width="60%" alt=""/>
</center>

<p>没有别的信息了，凑合着看吧。</p>
<p><b> 光纤通道 </b></p>
<blockquote>
<p>其为英文字母Fibre Channel的缩写。其最初设计也不是为了硬盘设计开发的接口，是专门为网络系统设计的，但随着存储系统对速度的需求，才逐渐应用到硬盘系统中。光纤通道的主要特性有：热插拔性、高速带宽、远程连接、连接设备数量大等。</p>
</blockquote>
<p>这里有个<a href="https://wenwen.sogou.com/z/q822282298.htm">搜狗回答</a><br>总之，用不到。</p>
<b>
<left style='color:green;'> 总结 </left>
</b>

<p>总结一下三种存储介质的常见接口：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://i.loli.net/2021/09/28/H4AxDaKteECdRk2.jpg" width="70%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;"> 如有疏漏，敬请谅解 </div>
</center>

<h4 id="显卡等插槽"><a href="#显卡等插槽" class="headerlink" title="显卡等插槽"></a>显卡等插槽</h4><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>一般来讲，CPU属于比较贵而又比较“挑”的零件。大家一般不会对CPU陌生，就是一个略有重量的金属片，底下有很多的引脚。<br>只要按照正确的方向放到主板上，用杠杆压好，上面涂一点硅脂然后盖上风扇就算组装好了（但一般将主板上的线连接得差不多得时候再装风扇，或是最后装，这玩意先装上去的话比较碍事）。</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PC</tag>
      </tags>
  </entry>
  <entry>
    <title>自制Link</title>
    <url>/2021/10/04/linkproduce/</url>
    <content><![CDATA[<h1 id="ST-link-amp-J-link"><a href="#ST-link-amp-J-link" class="headerlink" title="ST-link &amp; J-link"></a>ST-link &amp; J-link</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>累计了很多开源工程，想逐个复现一下。正好最近完成机器人走线，就挑了一个看上去没有那么费力项目：自制ST-link。虽然还没成功（短期内也不会继续了），但也值得把过程记录一下，按照这个过程走，大概率是没有问题的，我这里最终没有弄好应该是硬件的问题（毕竟开发板毕竟还是不是很适配）。然后，就意识到团队里制作J-link的工艺已经很成熟了，于是就转手准备做J-link了。</p>
</blockquote>
<p>制作ST-link的流程比较简单。</p>
<ol>
<li>硬件平台</li>
<li>烧固件</li>
</ol>
<p>完成！</p>
<p>参考的是稚晖君的开源工程，这里放上<a href="https://github.com/peng-zhihui">稚晖君的Github</a></p>
<p>硬件平台先不管了，直接烧固件。<br>先找一个能烧程序的器件（如ST-Link），和硬件平台。<br>找到固件（.bin），用专门烧录固件的程序烧录进去。<br>然后升级固件（用专门的软件，也可以在Keil5里面升级）<br>然后就可以用了。<br>然后不行，我裂了。虽然设备管理器能识别到ST-link，但不能用。<br>出现过以下几种问题：</p>
<ol>
<li>固件升级程序找不到ST-link<br>卡顿一会（卡顿到Windows提示.exe未响应）之后，就出现以下报错：<blockquote>
<p>No ST-Link found after GoToUsbLoader command. wait for the end of USB enumeration then try again.</p>
</blockquote>
</li>
</ol>
<p>但是这个报错有的时候会消失，正常升级了程序之后再卡死，然后又找不到了（合着就是刚升级完翻脸不认人了），然后再测试的时候Keil5还是会提示版本过低，笑死了。<br>使用现成的ST-link不会出现上述问题。</p>
<ol start="2">
<li>烧录程序找不到ST-link<br>我用的就是Utility,最基本的了。硬是出现了三种报错。<br>第一种<blockquote>
<p>Can not connect to target! Please select “Connect Under Reset” mode from Target-&gt;Settings menu and try again.  If you’re trying to connect to a low frequency application , please select a lower SWD Frequency mode from Target-&gt;Settings menu.”</p>
</blockquote>
</li>
</ol>
<p>第二种<br>具体的报错忘记了，大意就是：我们检测到你在向一块F103的单片机烧录程序，那你就不要使用Connect Under Reset这个模式了，使用normal的模式就好了。<br>XS，刚好与第一种报错相反。</p>
<p>第三种<br>大意为：ST-link USB连接失败。<br>最直接，就是没连上。重插就好了。</p>
<p>用现成的ST-link不会出现上述问题。<br>对于第一种情况，有可能他说的是对的。这个时候就是在使用一些板子的时候，是需要配合ST-link的复位引脚使用的。除了要修改连接模式之外，还需要连接上ST-link和单品机的复位引脚。<a href="https://blog.csdn.net/panxianzhan/article/details/104798641">有文在此</a></p>
<ol start="3">
<li><p>stm32 read out protection<br>这个是解决了的，是这个固件的保护，解决方法如下：<br>stm32-link utility中设置target-&gt;options bytes，将protection去掉，apply则可以工作了</p>
</li>
<li><p>ST LINK is not in the DFU mode plesse restart it<br>这个问题需要升级固件解决，而且插上ST-link就得马上升级固件，不能干其他的。<a href="https://blog.csdn.net/sinat_29891353/article/details/82778695">CSDN</a>有一篇文章有介绍。<br>不过呢，由于单纯固件升级的问题没有解决，这个问题也就无从解决。</p>
</li>
<li><p>Keil5无法进入Debug mode。<br>如上，就是提示无法进入这个mode。</p>
</li>
</ol>
<p>大概能回忆起这么多。<br>这里还有一位兄台修ST-link的<a href="https://blog.csdn.net/qq_20222919/article/details/111631286">文章</a>,有兴趣可以看一下。</p>
<p>J-link的事以后再说。<br>未完待续。</p>
<p>这个项目暂停了，看看之后是否有时间继续······</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>ST-link</tag>
        <tag>J-link</tag>
      </tags>
  </entry>
  <entry>
    <title>剪视频的一点心得</title>
    <url>/2021/10/11/upmakingmovie/</url>
    <content><![CDATA[<h1 id="Acquaintance-of-making-movie"><a href="#Acquaintance-of-making-movie" class="headerlink" title="Acquaintance of making movie"></a>Acquaintance of making movie</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>大二上学期一共剪了两个视频了。一个是作为“718赛务副队”的赛务新生考核视频（虽然最后一个人都没有完成），另一个是马原作业。这个马原作业的话，性质跟大计作业差不太多，但没学到什么东西（如果接受了5个小时马克思主义原理熏陶也算的话）。赛务考核倒是然我学了不少，至少会了预设转场和基本图形。这都是很重要的东西，技术不高，效果很好。</p>
</blockquote>
]]></content>
      <categories>
        <category>UPUP</category>
      </categories>
      <tags>
        <tag>PR</tag>
      </tags>
  </entry>
</search>
