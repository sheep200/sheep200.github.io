<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome gods!</title>
    <url>/2021/08/03/hello-world/</url>
    <content><![CDATA[<h2 id="Welcome-gods"><a href="#Welcome-gods" class="headerlink" title="Welcome gods!"></a>Welcome gods!</h2><h3 id="LF-mac"><a href="#LF-mac" class="headerlink" title="LF.mac"></a>LF.mac</h3><h3 id="luv-letters"><a href="#luv-letters" class="headerlink" title="luv_letters"></a><a href="https://dancekey.github.io/">luv_letters</a></h3><h3 id="BIA"><a href="#BIA" class="headerlink" title="BIA"></a>BIA</h3><p>芜湖！</p>
]]></content>
      <categories>
        <category>gods</category>
      </categories>
      <tags>
        <tag>gods!</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾电源板 &amp; 延期电赛 Best match!</title>
    <url>/2021/08/07/powerPCB/</url>
    <content><![CDATA[<h1 id="Non-existing-electronic-design-competition"><a href="#Non-existing-electronic-design-competition" class="headerlink" title="Non-existing electronic design competition"></a>Non-existing electronic design competition</h1><p>不存在的电赛</p>
<hr>
<blockquote>
<p>引子<br>由于这个新的病毒所带来的疫情，智能车竞赛以一种既坎坷又顺利的方式度过了。<br><del>甚至有一个单车组不用参加国赛就可以拿国二，大酸</del><br>最玄幻的展开真就被我们这一届赶上了</p>
</blockquote>
<hr>
<h2 id="说说电赛"><a href="#说说电赛" class="headerlink" title="说说电赛~"></a>说说电赛~</h2><p>先是延期一周，然后就变成了<strong>无限制延期</strong>，官方发布的通知就变成了等到疫情好转再<em>择机举行</em>。<br>反正是近期无望了，疫情也是没有办法的事。<br>我就没什么脾气，本来没有什么准备时间的一场没有把握的比赛，突然有了相当长的准备时间，反而很不适应。<br>不知道从何做起的话，就画画<strong>电源板</strong>吧！<br><del>总算回到正题</del></p>
<h2 id="电源板传"><a href="#电源板传" class="headerlink" title="电源板传"></a>电源板传</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://www.hualigs.cn/image/610eb7d47a69a.jpg" width="40%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">看“板”娘——雷蛇小姐</div>
</center>

<p>电源板又称供电板，功能很容易理解，就是插上去一块电赛标准的<em>12V电池</em>，能给我输出很多种不同的电压的板子。用来给各种外设供电的。<br>基本上回到家才开始设计的。<br>第一天完成元器件的选型和原理图的绘制。<br>第二天完成封装的导出绘制和添加，以及元器件的布局。<br>第三天上午完成了布线和检查，中午就交付打板了。<br>基本上是边摸鱼边干活，在家效率还是比较低。而且确实有很久都没有从头设计板子了，自从上个寒假设计完了一套主板电驱运放的方案，期间也就做了一版新运放，基本操作也就是对原方案缝缝补补以及修板子，至于交互板就更没有技术含量了，做PCB有些生疏了。<br>而且全程我查到的资料比较少，主要是参考了之前打电赛的某些队伍的技术报告，我看到的报告对电源板的设计并不是很详细。我的这块板基本上是融合一些技术报告的内容再加上我自己的想象设计出来的。那些技术报告参差不齐的，到时候能不能满足要求都难说_(:з」∠)_<br><strong>因为我根本就不知道要用哪些外设啊喂！</strong></p>
<h2 id="电源板参数"><a href="#电源板参数" class="headerlink" title="电源板参数"></a>电源板参数</h2><p>目前还不知道能不能用，就放一张原理图凑合一下罢<br><a href="https://www.hualigs.cn/image/610eb522a8264.jpg">电源板原理图</a><br>这里面最让我心虚的一点就是正负12V没有稳压，等于说正负电源就只有电源正负电压和5V正负电压，如果用到12V双电源很大概率要翻车。</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python图像边缘检测</title>
    <url>/2021/08/08/imageEdge/</url>
    <content><![CDATA[<h1 id="图像边缘检测（多图警告）"><a href="#图像边缘检测（多图警告）" class="headerlink" title="图像边缘检测（多图警告）"></a>图像边缘检测（多图警告）</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>画完了电源板厂家还没做好，这几天是闲的。本来画板子的时候因为各种事情心烦意乱的非常烦躁，现在又感觉非常空虚····<br>突然想起来画板的时候遇到的一个问题，就是那个看板娘丝印的处理。AD在导入图像的时候只能导入二值图，而原本一个丰富多彩的图像转化成灰度图，再转化成二值图的最终效果实在是太差了，只剩下色块，根本认不出来，后来是还是我自己用数位板描出来了五官，添加了亮部和暗部的一点细节，最终的看板娘二值图才勉强能看。用PS直接处理弄弄图标什么的还凑合，弄一个稍微复杂的图像就根本不行（可能是我PS技术太烂了罢）。<br>此时我就想起来之前见同学用Python做了个图像边缘识别，觉得把边缘识别得到的图像与PS直接做出来的图像结合一下，前者负责勾勒物体轮廓，后者负责填充明暗，效果应该会好上不少。于是今天就来复现一下同学的图像处理~<br>废话少说！</p>
</blockquote>
<h2 id="前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。"><a href="#前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。" class="headerlink" title="前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。"></a>前排提醒：本人为究极小白，目前的方案还不完备，效果并不特别理想，后续会尽力完善。</h2><p>以一张 <strong>红泳装皮肤同人图</strong> 为例，这是原图：</p>
<center>
<img src="https://www.hualigs.cn/image/610faeea0295d.jpg" width="40%" alt=""/>
</center>

<h3 id="如果用PS像上面描述的那样处理的话，效果是这样的"><a href="#如果用PS像上面描述的那样处理的话，效果是这样的" class="headerlink" title="如果用PS像上面描述的那样处理的话，效果是这样的~"></a>如果用PS像上面描述的那样处理的话，效果是这样的~</h3><h4 id="先PS调成灰度图："><a href="#先PS调成灰度图：" class="headerlink" title="先PS调成灰度图："></a>先PS调成灰度图：</h4><center>
<img src="https://www.hualigs.cn/image/610fa7069b643.jpg" width="40%" alt=""/>
</center>

<h4 id="再PS色彩分离，将色阶将至2（黑和白）"><a href="#再PS色彩分离，将色阶将至2（黑和白）" class="headerlink" title="再PS色彩分离，将色阶将至2（黑和白）"></a>再PS色彩分离，将色阶将至2（黑和白）</h4><center>
<img src="https://www.hualigs.cn/image/610fa6fde0430.jpg" width="40%" alt=""/>
</center>
<center style='color:gray;'> 好像也挺帅？ </center>

<p>这张还可以看出五官，但是相信我，很多图像是不行的，而且大量的亮部和暗部的轮廓都会消失。<br>下面就来尝试用Python处理一下这张图片吧~</p>
<h1 id="基础的Python图像边缘识别"><a href="#基础的Python图像边缘识别" class="headerlink" title="基础的Python图像边缘识别"></a>基础的Python图像边缘识别</h1><p>这里用的图像处理的库是OpenCv的。</p>
<h2 id="1-库的安装"><a href="#1-库的安装" class="headerlink" title="1.库的安装"></a>1.库的安装</h2><center style='color:gray;'> 安装库是第一步，也是最后一步，什么叫面向CSDN编程啊（战术后仰</center>


<p>电脑上需要有Python，我用的是Python3.6.4<br>首先要安装numpy，命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>
<p>安装完之后再安装cv:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install opencv_python</span><br></pre></td></tr></table></figure>
<p>这样库就安好了</p>
<blockquote>
<p>因为我不是在新电脑上学的啊，原来可能就有一些库，要完成接下来的操作可能还会缺一个库，就是matplot。这个库是Python画图用的，并不是必须的。不过建议自己搜索安装一个。</p>
</blockquote>
<h2 id="2-库引入"><a href="#2-库引入" class="headerlink" title="2.库引入"></a>2.库引入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>没什么好说的</p>
<h2 id="3-图像读取"><a href="#3-图像读取" class="headerlink" title="3.图像读取"></a>3.图像读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">original_img = cv2.imread(<span class="string">&quot;D:/red.jpg&quot;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这个cv2.imread函数除了可以指定图片的地址，还可以指定读取的通道数。像这里用的是 0 ，这样其实读出来的图像就已经是灰度图了。<br>把后面的“，0”去掉，图像才会是原图。</p>
<h2 id="4-canny边缘检测"><a href="#4-canny边缘检测" class="headerlink" title="4.canny边缘检测"></a>4.canny边缘检测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img1 = cv2.GaussianBlur(original_img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">canny = cv2.Canny(img1, <span class="number">50</span>, <span class="number">150</span>)</span><br></pre></td></tr></table></figure>
<p>canny函数只能处理灰度图，前面已经完成了彩图到灰度图的转化。<br>用高斯平滑处理原图像降噪。<br>再用canny指定最大和最小阈值，提取边缘。</p>
<blockquote>
<p>OpenCV-Python中Canny函数的原型为：<br>edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]])<br>必要参数：<br>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图；<br>第二个参数是阈值1；<br>第三个参数是阈值2。<br>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候用较小的第一个阈值用于将这些间断的边缘连接起来。<br>原文链接：<a href="https://blog.csdn.net/sunny2038/article/details/9202641">https://blog.csdn.net/sunny2038/article/details/9202641</a></p>
</blockquote>
<h2 id="5-色彩反向"><a href="#5-色彩反向" class="headerlink" title="5.色彩反向"></a>5.色彩反向</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height,width = canny.shape</span><br><span class="line">cannyturn = np.zeros((height,width,<span class="number">1</span>),np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        cannyturn[i,j] = <span class="number">255</span> - canny[i,j]</span><br></pre></td></tr></table></figure>
<p>这一步只是为了用黑色显示轮廓，白色当背景而已。canny默认的是黑色背景，白色轮廓。<br>方法非常无脑，生成另外一个相同大小的图像，然后将原图像的每一个像素点颜色数值反过来，赋给新图像。就完事了。<br>这一步可以省去，只不过是用AD脚本转化的时候方便一点而已。</p>
<h2 id="6-画图显示"><a href="#6-画图显示" class="headerlink" title="6.画图显示"></a>6.画图显示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(original_img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),plt.imshow(canny,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Canny&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这一步是为了将图像显示一下，简单对比一下效果。</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 3px 6px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/610fb91c5a155.jpg" width="80%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">这一步运行弹出的窗口</div>
</center>
同样可以省去的

<h2 id="7-图像保存"><a href="#7-图像保存" class="headerlink" title="7.图像保存"></a>7.图像保存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;black2.jpg&#x27;</span>,cannyturn)</span><br></pre></td></tr></table></figure>
<p>默认保存在Python程序所在的文件夹<br>最终效果：</p>
<center>
<img src="https://www.hualigs.cn/image/610fa704c408f.jpg" width="40%" alt=""/>
</center>
<center style='color:gray;'> 建议点开看 </center>
如果觉得边缘还是不明显的话，可以降低canny函数的阈值。
而且上面所述的方法忽略了一步，就是彩图向灰度图的转化。实际上RGB彩图向灰度图的转化有很多种方法，这里是在采集图像的时候就直接按照灰度通道采集。如果在这里做些手脚的话，效果也许会更好。这会意味着更大的调整空间 ~~以及更多参数要调~~

<p>不过就观感来看，这个轮廓图相较于单纯的二值图过分单薄了些。后续我会考虑如何用Python将两者结合起来，兼顾轮廓与明暗色块。这样放在电路板上当看“板”娘才有范儿~</p>
<hr>
<center style='color:green;'> 更新分割线 2021/8/8（没错还是今天） </center>

<blockquote>
<h2 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h2><p>受到那个粗暴的反向方法的启发，我弄了一个二值图与轮廓图的融合方法。最终成品效果应该是比单独的两张图都好上一些的。反正出来之后，效果就是预想的效果，心中有一丝没有遇上惊喜的失落。</p>
</blockquote>
<h1 id="二值图与轮廓图的融合"><a href="#二值图与轮廓图的融合" class="headerlink" title="二值图与轮廓图的融合"></a>二值图与轮廓图的融合</h1><h2 id="1-二值图的获取"><a href="#1-二值图的获取" class="headerlink" title="1.二值图的获取"></a>1.二值图的获取</h2><p>之前用PS获得过二值图，Python中还需要完成一步灰度图向二值图的转化。<br>自创的转化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二值图生成</span></span><br><span class="line">height2,width2 = img1.shape</span><br><span class="line">bmp = np.zeros((height2,width2,<span class="number">1</span>),np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height2):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width2):</span><br><span class="line">        <span class="keyword">if</span> img1[i,j] &gt;= <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">255</span></span><br><span class="line">        <span class="keyword">elif</span> img1[i,j] &lt; <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>效果和用PS做出来的效果几乎一样~</p>
<center>
<img src="https://www.hualigs.cn/image/6110042694ef1.jpg" width="40%" alt=""/>
</center>

<h2 id="2-二值图与轮廓图的融合"><a href="#2-二值图与轮廓图的融合" class="headerlink" title="2.二值图与轮廓图的融合"></a>2.二值图与轮廓图的融合</h2><p>主要思路就是用轮廓的信息对二值图进行描绘<br>将二值图中白的地方刮黑，黑的地方刮白，以此呈现出被二值掉的轮廓。<br>上代码~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#融合--融合在bmp上</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height2):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width2):</span><br><span class="line">        <span class="keyword">if</span> canny[i,j] &gt; <span class="number">127</span>:</span><br><span class="line">            bmp[i,j] = <span class="number">255</span> - bmp[i,j]</span><br></pre></td></tr></table></figure>
<p>直接看最终效果~</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/611005f32a317.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">二值图能做到这样，已经是极限了罢（悲 </div>
</center>

<p>怎么说呢，这张图远看跟二值图没区别，近看才会有明显的效果。跟原来两张图一比较还是会好上一些。<br>有新的参数可以调了！<br>二值化的阈值。这个参数控制图片亮部和暗部的范围，对于整体观感是肯定有影响的。<br>能想到的改进方向还有轮廓的粗细，二值化算法等等，以后再说吧。</p>
<hr>
<center style='color:green;'> 更新分割线2021/8/9 </center>

<h1 id="动态调参"><a href="#动态调参" class="headerlink" title="动态调参"></a>动态调参</h1><blockquote>
<h2 id="引子-2"><a href="#引子-2" class="headerlink" title="引子"></a>引子</h2><p>既然之前提到了参数，对于效果不好的图像，最基础的操作当然是关掉页面，回到VScode中修改参数再运行一次。虽然这对于Python程序而言比较简单，毕竟是解释性的语言，对于动态调参的需求没有嵌入式那么高，我还是弄了一个动态调参的东西。实不实用不重要，重要是帅啊。</p>
</blockquote>
<p>在说动态调参之前，还有一个小玩意儿分享一下~</p>
<h2 id="0-图层蒙板"><a href="#0-图层蒙板" class="headerlink" title="0.图层蒙板"></a>0.图层蒙板</h2><p>既然是做图像处理，图层是一个很重要的概念。虽然Python并不能对一个图像保存多个图层进行处理（Adobe还是永远的神），但是可以在两张图片之间使用蒙板，这已经很有图层的味了。</p>
<blockquote>
<p>转念一想，图像既然是按照像素储存在二维数组里的，如果换成三维数组，那岂不是可以有很多层的图片？退一步讲，其实只要定义很多张相同大小的图片，人为的给他们排上顺序，其实就已经是图层了。格局小了.jpg</p>
</blockquote>
<p>先上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv2.bitwise_and(img,img,mask = detected_edges)</span><br></pre></td></tr></table></figure>
<p>同样是Opencv的函数，原理其实是对像素点进行“与”运算。<br>在这里detected_edges图像上只有黑色和白色，它作为蒙版后，其下的img图片对应白色的地方就可以保留，对应黑色的部分就会被遮盖。<br>之前生成的边缘图就是一个只有黑白两种颜色的图啊，如果将边缘图的阈值调的很低，作为蒙版去处理原图。就会得到一个有意思的效果。</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/6110cb519e84e.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">同样建议点开放大看</div>
</center>

<p>借此，就出现了一大批有关的图像处理函数。<br>用这些函数可以做很多P图的工作，比如将上图中的黑色镂空部分换成白色：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/6110e016b9436.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">从刮刮乐变成了彩铅~</div>
</center>

<p>这些函数别人的博客都将的很清楚了，我就不赘述了。<br><a href="https://www.cnblogs.com/ckAng/p/10843409.html">一堆函数</a> ，<a href="https://blog.csdn.net/weixin_35732969/article/details/83748054">以及用这些函数P图的实例</a></p>
<p>于是我就发现我昨天自己写的二值图算法和融合算法完全可以由这些函数代替。那种逐个像素点比对的方式运行速度很慢，我点击运行之后要等上10秒左右才能运行完一张图，完全比不上Opencv里边那些封装好的、高度优化的函数。小丑竟是我自己。<br>这些不能算是今天的重点，今天的重点是动态调参~</p>
<h2 id="cv2-createTrackbar"><a href="#cv2-createTrackbar" class="headerlink" title="cv2.createTrackbar"></a>cv2.createTrackbar</h2><p>直接上代码吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.lib.shape_base <span class="keyword">import</span> dstack</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;D:\Program doc\VScode\VS-code-py\PictureEdge/red.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CannyThreshold</span>(<span class="params">lowThreshold</span>):</span></span><br><span class="line">    detected_edges = cv2.GaussianBlur(gray,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">    detected_edges = cv2.Canny(detected_edges,lowThreshold,lowThreshold*ratio,apertureSize = kernel_size)</span><br><span class="line">    dst = cv2.bitwise_and(img,img,mask = detected_edges)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;canny demo&#x27;</span>,dst)</span><br><span class="line">    <span class="comment">#cv2.imwrite(&#x27;coloredgew.jpg&#x27;,dst)</span></span><br><span class="line"> </span><br><span class="line">lowThreshold = <span class="number">0</span></span><br><span class="line">max_lowThreshold = <span class="number">100</span></span><br><span class="line">ratio = <span class="number">3</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;canny demo&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cv2.createTrackbar(<span class="string">&#x27;Min threshold&#x27;</span>,<span class="string">&#x27;canny demo&#x27;</span>,lowThreshold, max_lowThreshold, CannyThreshold)</span><br><span class="line"> </span><br><span class="line">CannyThreshold(<span class="number">0</span>)  <span class="comment"># initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>感谢<a href="https://blog.csdn.net/sunny2038/article/details/9202641">原文</a>博主</p>
<blockquote>
<p>这里使用的显示窗口不是之前matplot的那一套。这里用的这一套有一点不舒服就是显示出来图像的大小是与显示屏分辨率挂钩的，也就是如果图片的分辨率大于显示屏的分辨率，就会生成一个超大的、超出屏幕的窗口，而且还无法放缩·····</p>
</blockquote>
<p>这里用到了Python函数的定义，而且这里还是回调函数。作用有点像嵌入式里面的服务函数。<br>这个cv2.createTrackbar函数就像是创建了一个外部中断，只要检测到滑块运动了，就会执行回调函数内的语句。后面的代码还在向后运行，不会受这个函数影响（最多就是在回调函数运行时被打断一下而已）</p>
<p>将代码中的cv2.imwrite(‘coloredgew.jpg’,dst)的注释去掉，就可以实时在文件夹中生成你在窗口里看到的图像文件了。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Deal with Markdowm!!</title>
    <url>/2021/08/08/dealwithMD/</url>
    <content><![CDATA[<h1 id="1-文本"><a href="#1-文本" class="headerlink" title="1.文本"></a>1.文本</h1><h2 id="1-1基础文本效果"><a href="#1-1基础文本效果" class="headerlink" title="1.1基础文本效果"></a>1.1基础文本效果</h2><h2 id="1-2略高文本效果"><a href="#1-2略高文本效果" class="headerlink" title="1.2略高文本效果"></a>1.2略高文本效果</h2><h3 id="1-2-1位置与颜色"><a href="#1-2-1位置与颜色" class="headerlink" title="1.2.1位置与颜色"></a>1.2.1位置与颜色</h3><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span> <span class="attr">style</span>=<span class="string">&#x27;color:black;&#x27;</span>&gt;</span></span> 看“板”娘——雷蛇小姐 <span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span> <span class="attr">style</span>=<span class="string">&#x27;color:blue;&#x27;</span>&gt;</span></span> 看“板”娘——雷蛇小姐 <span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<center style='color:black;'> 看“板”娘——雷蛇小姐 </center>
<center style='color:blue;'> 看“板”娘——雷蛇小姐 </center>

<h1 id="2-图片"><a href="#2-图片" class="headerlink" title="2.图片"></a>2.图片</h1><h2 id="2-1基础图片"><a href="#2-1基础图片" class="headerlink" title="2.1基础图片"></a>2.1基础图片</h2><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">雷蛇小姐</span>](<span class="link">https://www.hualigs.cn/image/610eb7d47a69a.jpg</span>)</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://www.hualigs.cn/image/610eb7d47a69a.jpg" alt="雷蛇小姐"></p>
<h2 id="2-2控制大小的图片"><a href="#2-2控制大小的图片" class="headerlink" title="2.2控制大小的图片"></a>2.2控制大小的图片</h2><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.hualigs.cn/image/610eb7d47a69a.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40%&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://www.hualigs.cn/image/610eb7d47a69a.jpg" width="40%" alt=""/></p>
<h2 id="2-3图片边框，标注，以及大小的控制"><a href="#2-3图片边框，标注，以及大小的控制" class="headerlink" title="2.3图片边框，标注，以及大小的控制"></a>2.3图片边框，标注，以及大小的控制</h2><p>代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">src</span>=<span class="string">&quot;https://www.hualigs.cn/image/610eb7d47a69a.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40%&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">display: inline-block;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">color: #999;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">padding: 2px;&quot;</span>&gt;</span></span>看“板”娘——雷蛇小姐<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
src="https://www.hualigs.cn/image/610eb7d47a69a.jpg" width="40%" alt=""/>
<br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;
color: #999;
padding: 2px;">看“板”娘——雷蛇小姐</div>
</center>]]></content>
      <categories>
        <category>blogwriting</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>When I Went Home</title>
    <url>/2021/08/04/wenthome/</url>
    <content><![CDATA[<h2 id="到家了，真不错"><a href="#到家了，真不错" class="headerlink" title="到家了，真不错~"></a>到家了，真不错~</h2>]]></content>
      <categories>
        <category>home</category>
      </categories>
      <tags>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title>关于FOC驱动器的尝试</title>
    <url>/2021/08/09/FOCtry/</url>
    <content><![CDATA[<h1 id="Field-Oriented-Control"><a href="#Field-Oriented-Control" class="headerlink" title="Field-Oriented Control"></a>Field-Oriented Control</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>回到家将近一个星期了，头两天做了个略显草率的电源板，因为实在是为了准备一下电赛嘛。趁着电源板没有到货，摸了摸Python的图像处理，现在也感觉差不多了。想起来之前老师说的立创上有电赛相关的内容。看到一个有关Odrive的，貌似是根据成熟的固件做的一套PCB。继续往下翻看到参考文献，发现有稚晖君的文章，毫不犹豫的点进去之后，发现是那篇关于<em><strong>FOC的知乎</strong></em>。看得我热血澎湃。不过，一个现在连在一块新单片机上配置脉冲计数都困难的我来讲，要复现绝非易事，但我还是要尝试一下~~</p>
</blockquote>
<center style='color:black;'> 

<h2 id="先将-稚晖君FOC神文-供在这里"><a href="#先将-稚晖君FOC神文-供在这里" class="headerlink" title="先将 稚晖君FOC神文 供在这里"></a>先将 <a href="https://zhuanlan.zhihu.com/p/147659820">稚晖君FOC神文</a> 供在这里</h2></center>

<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>我打算实现的是无刷电机带编码器的版本。虽然听说了无刷电机的无感控制，我还是感觉有感的简单易懂一些。</p>
<h3 id="P-1-单片机基础功能"><a href="#P-1-单片机基础功能" class="headerlink" title="P.1 单片机基础功能"></a>P.1 单片机基础功能</h3><p>FOC需要大量的数学计算，因此一块趁手的单片机比较重要。做车用的单片机是英飞凌的TC264，用那块单片机的话很多事都不用愁了，像什么PWM输出，编码器，ADC都是现成的。无奈放假逃离学校的时候什么都拿了，唯独忘了那几片单片机。手头上只有几片32的开发板。<br>初步计划用那F103C8T6，早晚都要会的</p>
<h3 id="P-2-功率与逻辑电路"><a href="#P-2-功率与逻辑电路" class="headerlink" title="P.2 功率与逻辑电路"></a>P.2 功率与逻辑电路</h3><p>仔细看了稚晖君的文章，在功率电路上不是很复杂，感觉用半桥驱动器可以实现。之前用IR2104搭H桥，这里不过是搭了一个三相的嘛（？<br>至于电流检测，文章中也提到了采样电阻和霍尔传感器两种方法，复现就行了。</p>
<h3 id="P-3-外设"><a href="#P-3-外设" class="headerlink" title="P.3 外设"></a>P.3 外设</h3><p>买一个编码器在C8T6上运行，串级PID三环，速度环和位置环都需要编码器的参与。<br>其次为了显示参数，需要一块屏幕。</p>
<h3 id="P-4-算法"><a href="#P-4-算法" class="headerlink" title="P.4 算法"></a>P.4 算法</h3><p>软件要实现大量的数学计算，文章的中描述的倒是能看懂。不过有些操作还是需要依靠单片机的外设实现，比如配置一个并非规律的占空比输出，我目前就没有头绪(莫非用IO口模拟？就算是这样也很不好写啊)<br>总之算法边走边看吧。</p>
<hr>
<center style='color:green;'> 2021/8/12 更新 </center>

<h2 id="当前进度"><a href="#当前进度" class="headerlink" title="当前进度"></a>当前进度</h2><h3 id="单片机SYSTEM"><a href="#单片机SYSTEM" class="headerlink" title="单片机SYSTEM"></a>单片机SYSTEM</h3><p>学习了一段时间Cube,用Cube做GPIO,ADC,UART都挺容易的，无奈没有调试工具，只有一块32ZET6的板子上自带了USB转TTL，好歹能做到数据收发。又花了一些时间在RTT上，但是最终没能将程序融进去，各种头文件乱飞，不是没定义就是重复定义。还是放弃RTT了，我做一个电机驱动也用不到那玩意。<br>买了一些调试工具和屏幕，等到了再继续吧。</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><h3 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h3><p>视觉组的培训方案出来了，但是电控和硬件还没有。我是要报硬件的啊，所以还是抓紧做一些硬件有关的事吧。设计个一带有三端的电驱板，包括电流检测功能。但实际上这个玩意有集成的芯片，只需要对这个芯片输入三路PWM，为这个芯片接上霍尔传感器，这个芯片就可以依照PWM控制电机并且通过通信协议的引脚向主控芯片传输电流信号，同时还可以通过这个协议烧固件。缺陷就是电流太小，大概只有1A，所以我打算自己做一块板子实现这些功能，当然所有的传感和程序都直接交给主控完成。</p>
<p>重新回去看了一遍稚晖君的FOC视频，对自己为什么要做这个玩意产生的严重的质疑。<br>我艹，这是我所能企及的吗？我在干嘛？</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>FOC</tag>
        <tag>MCCM</tag>
      </tags>
  </entry>
  <entry>
    <title>学Cube,走向懒狗人生</title>
    <url>/2021/08/11/STM32Cube/</url>
    <content><![CDATA[<h1 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h1><blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>要做FOC，我对自己差多少东西还是有点数的。单片机都没怎么学通，别说寄存器了，就连一块32的芯片用Cube写都不熟悉，完全一副被例程惯坏了的样子。从最基础的开始学有一些来不及了，既然打算用手上的这一块C8T6，就直接用Cube写就行了。昨天已经烧进去程序了，现在就是学习如何调通各个外设和模块的事了。</p>
</blockquote>
<h2 id="Cube点亮LED"><a href="#Cube点亮LED" class="headerlink" title="Cube点亮LED"></a>Cube点亮LED</h2><p>1.设置使用外部晶振<br>2.设置时钟树参数<br>3.设置SYS的Debug模式<br>4.在芯片图上找到引脚，配置成GPIO输出<br>5.左边GPIO配置：初始电平、输出模式、上拉下拉，频率，引脚标签<br>6.工程配置：起名，工程文件夹，使用的编译软件，是否复制所有库文件，.c.h分开<br>7.生成工程<br>8.配置下载器<br>9.调用函数<br>10.下载</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>MCCM</tag>
      </tags>
  </entry>
</search>
